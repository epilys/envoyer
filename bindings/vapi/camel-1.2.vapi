/* camel-1.2.vapi generated by vapigen, do not modify. */

[CCode (cprefix = "Camel", gir_namespace = "Camel", gir_version = "1.2", lower_case_cprefix = "camel_")]
namespace Camel {
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_address_get_type ()")]
	public class Address : GLib.Object {
		public weak GLib.GenericArray<void*> addresses;
		[CCode (has_construct_function = false)]
		public Address ();
		public virtual int cat (Camel.Address source);
		public int copy (Camel.Address source);
		public virtual int decode (string raw);
		public virtual string encode ();
		public virtual string format ();
		public int length ();
		public Camel.Address new_clone ();
		public virtual void remove (int index);
		public virtual int unformat (string raw);
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class AsyncClosure {
		public static void callback (GLib.Object source_object, GLib.AsyncResult result, void* closure);
		public void free ();
		public unowned GLib.AsyncResult wait ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_block_file_get_type ()")]
	public class BlockFile : GLib.Object {
		public weak GLib.Queue block_cache;
		public int block_cache_count;
		public int block_cache_limit;
		public size_t block_size;
		public weak GLib.HashTable<void*,void*> blocks;
		public int fd;
		public Camel.BlockFileFlags flags;
		public weak string path;
		public Camel.BlockRoot root;
		public Camel.Block root_block;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak char[] version;
		[CCode (has_construct_function = false)]
		public BlockFile (string path, int flags, char version, size_t block_size);
		public void attach_block (Camel.Block bl);
		public int @delete ();
		public void detach_block (Camel.Block bl);
		public int free_block (Camel._block_t id);
		[NoWrapper]
		public virtual int init_root ();
		public int rename (string path);
		public int sync ();
		public int sync_block (Camel.Block bl);
		public void touch_block (Camel.Block bl);
		public void unref_block (Camel.Block bl);
		[NoWrapper]
		public virtual int validate_root ();
	}
	[CCode (cheader_filename = "camel/camel.h", ref_function = "camel_cert_ref", type_id = "camel_cert_get_type ()", unref_function = "camel_cert_unref")]
	[Compact]
	public class Cert {
		public weak string fingerprint;
		public weak string hostname;
		public weak string issuer;
		public weak GLib.Bytes rawcert;
		public int refcount;
		public weak string subject;
		public Camel.CertTrust trust;
		[CCode (has_construct_function = false)]
		public Cert ();
		public bool load_cert_file () throws GLib.Error;
		public Camel.Cert @ref ();
		public bool save_cert_file (GLib.ByteArray der_data) throws GLib.Error;
		public void unref ();
	}
	[CCode (cheader_filename = "camel/camel.h", lower_case_csuffix = "certdb", type_id = "camel_certdb_get_type ()")]
	public class CertDB : GLib.Object {
		[CCode (has_construct_function = false)]
		public CertDB ();
		[NoWrapper]
		public virtual Camel.Cert cert_load (void* istream);
		[NoWrapper]
		public virtual int cert_save (Camel.Cert cert, void* ostream);
		public void clear ();
		public static Camel.CertDB get_default ();
		public Camel.Cert get_host (string hostname, string fingerprint);
		[NoWrapper]
		public virtual int header_load (void* istream);
		[NoWrapper]
		public virtual int header_save (void* ostream);
		public GLib.SList<Camel.Cert> list_certs ();
		public int load ();
		public void put (Camel.Cert cert);
		public void remove_host (string hostname, string fingerprint);
		public int save ();
		public void set_default ();
		public void set_filename (string filename);
		public void touch ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_cipher_context_get_type ()")]
	public class CipherContext : GLib.Object {
		[CCode (has_construct_function = false)]
		public CipherContext (Camel.Session session);
		public async Camel.CipherValidity decrypt (Camel.MimePart ipart, Camel.MimePart opart, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.CipherValidity decrypt_sync (Camel.MimePart ipart, Camel.MimePart opart, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool encrypt (string userid, GLib.GenericArray<string> recipients, Camel.MimePart ipart, Camel.MimePart opart, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool encrypt_sync (string userid, GLib.GenericArray<string> recipients, Camel.MimePart ipart, Camel.MimePart opart, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public unowned Camel.Session get_session ();
		public virtual unowned string hash_to_id (Camel.CipherHash hash);
		public virtual Camel.CipherHash id_to_hash (string id);
		public async bool sign (string userid, Camel.CipherHash hash, Camel.MimePart ipart, Camel.MimePart opart, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool sign_sync (string userid, Camel.CipherHash hash, Camel.MimePart ipart, Camel.MimePart opart, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async Camel.CipherValidity verify (Camel.MimePart ipart, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.CipherValidity verify_sync (Camel.MimePart ipart, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public Camel.Session session { get; construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "camel_cipher_validity_get_type ()")]
	[Compact]
	public class CipherValidity {
		public weak GLib.Queue children;
		[CCode (has_construct_function = false)]
		public CipherValidity ();
		public void add_certinfo (Camel._cipher_validity_mode_t mode, string name, string email);
		public void add_certinfo_ex (Camel._cipher_validity_mode_t mode, string name, string email, void* cert_data, void* cert_data_free, void* cert_data_clone);
		public void clear ();
		public Camel.CipherValidity clone ();
		public void envelope (Camel.CipherValidity valid);
		public void free ();
		public string get_description ();
		public bool get_valid ();
		public void init ();
		public void set_description (string description);
		public void set_valid (bool valid);
	}
	[CCode (cheader_filename = "camel/camel.h", ref_function = "camel_content_disposition_ref", type_id = "camel_content_disposition_get_type ()", unref_function = "camel_content_disposition_unref")]
	[Compact]
	public class ContentDisposition {
		public weak string disposition;
		public void* @params;
		public uint refcount;
		public static Camel.ContentDisposition decode (string @in);
		public string format ();
		public Camel.ContentDisposition @ref ();
		public void unref ();
	}
	[CCode (cheader_filename = "camel/camel.h", ref_function = "camel_content_type_ref", type_id = "camel_content_type_get_type ()", unref_function = "camel_content_type_unref")]
	[Compact]
	public class ContentType {
		public void* @params;
		public uint refcount;
		public weak string subtype;
		public weak string type;
		[CCode (has_construct_function = false)]
		public ContentType (string type, string subtype);
		public static Camel.ContentType decode (string @in);
		public void dump ();
		public string format ();
		public bool @is (string type, string subtype);
		public unowned string param (string name);
		public Camel.ContentType @ref ();
		public void set_param (string name, string value);
		public string simple ();
		public void unref ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_data_cache_get_type ()")]
	public class DataCache : GLib.Object {
		[CCode (has_construct_function = false)]
		public DataCache (string path) throws GLib.Error;
		public GLib.IOStream add (string path, string key) throws GLib.Error;
		public void clear (string path);
		public GLib.IOStream @get (string path, string key) throws GLib.Error;
		public string get_filename (string path, string key);
		public unowned string get_path ();
		public int remove (string path, string key) throws GLib.Error;
		public void set_expire_access (long when);
		public void set_expire_age (long when);
		public void set_path (string path);
		public string path { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_data_wrapper_get_type ()")]
	public class DataWrapper : GLib.Object {
		public Camel.TransferEncoding encoding;
		public weak Camel.ContentType mime_type;
		public uint offline;
		[CCode (has_construct_function = false)]
		public DataWrapper ();
		public async bool construct_from_input_stream (GLib.InputStream input_stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool construct_from_input_stream_sync (GLib.InputStream input_stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool construct_from_stream (Camel.Stream stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool construct_from_stream_sync (Camel.Stream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async ssize_t decode_to_output_stream (GLib.OutputStream output_stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual ssize_t decode_to_output_stream_sync (GLib.OutputStream output_stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async ssize_t decode_to_stream (Camel.Stream stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual ssize_t decode_to_stream_sync (Camel.Stream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public unowned GLib.ByteArray get_byte_array ();
		public virtual string get_mime_type ();
		public virtual unowned Camel.ContentType get_mime_type_field ();
		public virtual bool is_offline ();
		public virtual void set_mime_type (string mime_type);
		public virtual void set_mime_type_field (Camel.ContentType mime_type);
		public async ssize_t write_to_output_stream (GLib.OutputStream output_stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual ssize_t write_to_output_stream_sync (GLib.OutputStream output_stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async ssize_t write_to_stream (Camel.Stream stream, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual ssize_t write_to_stream_sync (Camel.Stream stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_filter_driver_get_type ()")]
	public class FilterDriver : GLib.Object {
		[CCode (has_construct_function = false)]
		public FilterDriver (void* session);
		public void add_rule (string name, string match, string action);
		public int filter_folder (Camel.Folder folder, Camel.UIDCache cache, GLib.GenericArray<string> uids, bool remove, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public int filter_mbox (string mbox, string original_source_url, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public int filter_message (Camel.MimeMessage message, Camel.MessageInfo info, string uid, Camel.Folder source, string store_uid, string original_store_uid, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void flush () throws GLib.Error;
		public int remove_rule_by_name (string name);
		public void set_default_folder (Camel.Folder def);
		public void set_folder_func (Camel.FilterGetFolderFunc get_folder);
		public void set_logfile (void* logfile);
		public void set_play_sound_func (Camel.FilterPlaySoundFunc func);
		public void set_shell_func (Camel.FilterShellFunc func);
		public void set_status_func (Camel.FilterStatusFunc func);
		public void set_system_beep_func (Camel.FilterSystemBeepFunc func);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_filter_input_stream_get_type ()")]
	public class FilterInputStream : GLib.FilterInputStream {
		[CCode (has_construct_function = false, type = "GInputStream*")]
		public FilterInputStream (GLib.InputStream base_stream, Camel.MimeFilter filter);
		public unowned Camel.MimeFilter get_filter ();
		public Camel.MimeFilter filter { get; construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_filter_output_stream_get_type ()")]
	public class FilterOutputStream : GLib.FilterOutputStream {
		[CCode (has_construct_function = false, type = "GOutputStream*")]
		public FilterOutputStream (GLib.OutputStream base_stream, Camel.MimeFilter filter);
		public unowned Camel.MimeFilter get_filter ();
		public Camel.MimeFilter filter { get; construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_folder_get_type ()")]
	public abstract class Folder : Camel.Object {
		public Camel.FolderFlags folder_flags;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] later;
		public Camel.MessageFlags permanent_flags;
		public weak Camel.FolderSummary summary;
		[CCode (has_construct_function = false)]
		protected Folder ();
		public async bool append_message (Camel.MimeMessage message, Camel.MessageInfo info, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool append_message_sync (Camel.MimeMessage message, Camel.MessageInfo info, string appended_uid, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual int cmp_uids (string uid1, string uid2);
		public virtual uint32 count_by_expression (string expression, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void @delete ();
		[NoWrapper]
		public virtual void delete_ ();
		public string dup_description ();
		public string dup_display_name ();
		public string dup_full_name ();
		public static GLib.Quark error_quark ();
		public async bool expunge (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool expunge_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void free_deep (GLib.GenericArray<string> array);
		public void free_shallow (GLib.GenericArray<string> array);
		public virtual void free_summary (GLib.GenericArray<Camel.MessageInfo> array);
		public virtual void free_uids (GLib.GenericArray<string> array);
		public virtual void freeze ();
		public int get_deleted_message_count ();
		public unowned string get_description ();
		public unowned string get_display_name ();
		public virtual string get_filename (string uid) throws GLib.Error;
		public int get_frozen_count ();
		public unowned string get_full_name ();
		public async unowned Camel.MimeMessage get_message (string message_uid, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual int get_message_count ();
		[Deprecated]
		public virtual Camel.MessageFlags get_message_flags (string uid);
		public virtual Camel.MessageInfo get_message_info (string uid);
		public virtual unowned Camel.MimeMessage get_message_sync (string message_uid, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[Deprecated]
		public virtual bool get_message_user_flag (string uid, string name);
		[Deprecated]
		public virtual unowned string get_message_user_tag (string uid, string name);
		public void* get_parent_store ();
		public virtual Camel.MessageFlags get_permanent_flags ();
		public async Camel.FolderQuotaInfo get_quota_info (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.FolderQuotaInfo get_quota_info_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual unowned GLib.GenericArray<Camel.MessageInfo> get_summary ();
		public virtual unowned GLib.GenericArray<string> get_uids ();
		public virtual unowned GLib.GenericArray<string> get_uncached_uids (GLib.GenericArray<string> uids) throws GLib.Error;
		[Deprecated]
		public int get_unread_message_count ();
		[NoWrapper]
		public virtual bool has_search_capability ();
		public bool has_summary_capability ();
		public virtual bool is_frozen ();
		public void @lock ();
		public async bool purge_message_cache (string start_uid, string end_uid, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool purge_message_cache_sync (string start_uid, string end_uid, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool refresh_info (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool refresh_info_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual void rename (string new_name);
		public virtual GLib.GenericArray<string> search_by_expression (string expression, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual GLib.GenericArray<string> search_by_uids (string expression, GLib.GenericArray<string> uids, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual void search_free (GLib.GenericArray<string> result);
		public void set_description (string description);
		public void set_display_name (string display_name);
		public void set_full_name (string full_name);
		public void set_lock_async (bool skip_folder_lock);
		[Deprecated]
		public virtual bool set_message_flags (string uid, Camel.MessageFlags flags, Camel.MessageFlags @set);
		[Deprecated]
		public virtual void set_message_user_flag (string uid, string name, bool value);
		[Deprecated]
		public virtual void set_message_user_tag (string uid, string name, string value);
		public virtual void sort_uids (GLib.GenericArray<string> uids);
		public async bool synchronize (bool expunge, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public async bool synchronize_message (string message_uid, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool synchronize_message_sync (string message_uid, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual bool synchronize_sync (bool expunge, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual void thaw ();
		public async bool transfer_messages_to (GLib.GenericArray<string> message_uids, Camel.Folder destination, bool delete_originals, int io_priority, GLib.Cancellable? cancellable, out GLib.GenericArray<string> transferred_uids) throws GLib.Error;
		public virtual bool transfer_messages_to_sync (GLib.GenericArray<string> message_uids, Camel.Folder destination, bool delete_originals, out GLib.GenericArray<string> transferred_uids, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void unlock ();
		public string description { get; set construct; }
		public string display_name { get; set construct; }
		public string full_name { get; set construct; }
		public Camel.Store parent_store { get; construct; }
		[HasEmitter]
		public virtual signal void changed (void* changes);
		public virtual signal void deleted ();
		public virtual signal void renamed (string old_name);
	}
	[CCode (cheader_filename = "camel/camel.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "camel_folder_info_get_type ()")]
	[Compact]
	public class FolderInfo {
		public void* child;
		public weak string display_name;
		public Camel.FolderInfoFlags flags;
		public weak string full_name;
		public void* next;
		public void* parent;
		public int32 total;
		public int32 unread;
		[CCode (has_construct_function = false)]
		public FolderInfo ();
		public static Camel.FolderInfo build (GLib.GenericArray<Camel.FolderInfo> folders, string namespace_, char separator, bool short_names);
		public Camel.FolderInfo clone ();
		public void free ();
	}
	[CCode (cheader_filename = "camel/camel.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "camel_folder_quota_info_get_type ()")]
	[Compact]
	public class FolderQuotaInfo {
		public weak string name;
		public void* next;
		public uint64 total;
		public uint64 used;
		[CCode (has_construct_function = false)]
		public FolderQuotaInfo (string name, uint64 used, uint64 total);
		public Camel.FolderQuotaInfo clone ();
		public void free ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_folder_search_get_type ()")]
	public class FolderSearch : GLib.Object {
		public weak Camel.Index body_index;
		public weak Camel.MessageInfo current;
		public weak Camel.MimeMessage current_message;
		public weak Camel.Folder folder;
		public weak string last_search;
		public weak Camel.SExp sexp;
		public weak GLib.GenericArray<void*> summary;
		public weak GLib.GenericArray<void*> summary_set;
		[CCode (has_construct_function = false)]
		public FolderSearch ();
		[Deprecated (since = "3.8")]
		public void @construct ();
		public uint32 count (string expr, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void free_result (GLib.GenericArray<string> result);
		public GLib.GenericArray<string> search (string expr, GLib.GenericArray<string> uids, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void set_body_index (Camel.Index body_index);
		public void set_folder (Camel.Folder folder);
		public void set_summary (GLib.GenericArray<Camel.MessageInfo> summary);
		public static long util_add_months (long t, int months);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_folder_summary_get_type ()")]
	public class FolderSummary : GLib.Object {
		public weak string collate;
		public Camel.FolderSummaryFlags flags;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] later;
		public weak string sort_by;
		public long time;
		public uint32 version;
		[CCode (has_construct_function = false)]
		public FolderSummary (void* folder);
		public void add (Camel.MessageInfo info);
		public void add_preview (Camel.MessageInfo info);
		public bool check_uid (string uid);
		public bool clear () throws GLib.Error;
		public virtual void content_info_free (Camel.MessageContentInfo ci);
		[NoWrapper]
		public virtual bool content_info_to_db (Camel.MessageContentInfo info, void* mir);
		public uint count ();
		public static void free_array (GLib.GenericArray<string> array);
		public Camel.MessageInfo @get (string uid);
		public GLib.GenericArray<string> get_array ();
		public bool get_build_content ();
		public GLib.GenericArray<string> get_changed ();
		public uint32 get_deleted_count ();
		public void* get_folder ();
		public GLib.HashTable<weak string,weak int> get_hash ();
		public unowned Camel.Index get_index ();
		public uint32 get_info_flags (string uid);
		public uint32 get_junk_count ();
		public uint32 get_junk_not_deleted_count ();
		public bool get_need_preview ();
		public uint32 get_next_uid ();
		public uint32 get_saved_count ();
		public uint32 get_unread_count ();
		public uint32 get_visible_count ();
		public bool header_load_from_db (void* store, string folder_name) throws GLib.Error;
		public bool header_save_to_db () throws GLib.Error;
		public Camel.MessageInfo info_new_from_header (void* headers);
		public Camel.MessageInfo info_new_from_message (Camel.MimeMessage message, string bodystructure);
		public Camel.MessageInfo info_new_from_parser (Camel.MimeParser parser);
		public void insert (Camel.MessageInfo info, bool load);
		public bool load_from_db () throws GLib.Error;
		public void @lock ();
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_clone (Camel.MessageInfo info);
		[NoWrapper]
		public virtual void message_info_free (Camel.MessageInfo ci);
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_from_db (void* mir);
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_from_uid (string uid);
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_new_from_header (void* header);
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_new_from_message (Camel.MimeMessage message, string bodystructure);
		[NoWrapper]
		public virtual Camel.MessageInfo message_info_new_from_parser (Camel.MimeParser parser);
		public uint32 next_uid ();
		public virtual string next_uid_string ();
		public Camel.MessageInfo peek_loaded (string uid);
		public void prepare_fetch_all () throws GLib.Error;
		public bool remove (Camel.MessageInfo info);
		public bool remove_uid (string uid);
		public bool remove_uids (GLib.List<string> uids);
		public bool replace_flags (Camel.MessageInfo info);
		public bool save_to_db () throws GLib.Error;
		public void set_build_content (bool state);
		public void set_index (Camel.Index index);
		public void set_need_preview (bool preview);
		public void set_next_uid (uint32 uid);
		[NoWrapper]
		public virtual bool summary_header_from_db (void* fir);
		public void touch ();
		public void unlock ();
		public bool build_content { get; set; }
		public uint deleted_count { get; }
		public Camel.Folder folder { get; construct; }
		public uint junk_count { get; }
		public uint junk_not_deleted_count { get; }
		public bool need_preview { get; set; }
		public uint saved_count { get; }
		public uint unread_count { get; }
		public uint visible_count { get; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_gpg_context_get_type ()")]
	public class GpgContext : Camel.CipherContext {
		[CCode (has_construct_function = false, type = "CamelCipherContext*")]
		public GpgContext (Camel.Session session);
		public bool get_always_trust ();
		public bool get_prefer_inline ();
		public void set_always_trust (bool always_trust);
		public void set_prefer_inline (bool prefer_inline);
		public bool always_trust { get; set construct; }
		public bool prefer_inline { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_html_parser_get_type ()")]
	public class HTMLParser : GLib.Object {
		[CCode (has_construct_function = false)]
		public HTMLParser ();
		public unowned string attr (string name);
		public unowned GLib.GenericArray<string> attr_list (ref GLib.GenericArray<string> values);
		public unowned string left (int lenp);
		public void set_data (string start, int len, int last);
		public Camel._html_parser_t step (string datap, int lenp);
		public unowned string tag ();
	}
	[CCode (cheader_filename = "camel/camel.h", ref_function = "camel_header_address_ref", type_id = "camel_header_address_get_type ()", unref_function = "camel_header_address_unref")]
	[Compact]
	public class HeaderAddress {
		public weak string name;
		public void* next;
		public uint refcount;
		public Camel._header_address_t type;
		[CCode (cname = "v.addr")]
		public weak string v_addr;
		[CCode (cname = "v.members")]
		public void* v_members;
		[CCode (has_construct_function = false)]
		public HeaderAddress ();
		public void add_member (Camel.HeaderAddress member);
		public static Camel.HeaderAddress decode (string @in, string charset);
		public static string fold (string @in, size_t headerlen);
		[CCode (has_construct_function = false)]
		public HeaderAddress.group (string name);
		public static void list_append (Camel.HeaderAddress addrlistp, Camel.HeaderAddress addr);
		public static void list_append_list (Camel.HeaderAddress addrlistp, Camel.HeaderAddress addrs);
		public static void list_clear (Camel.HeaderAddress addrlistp);
		public string list_encode ();
		public string list_format ();
		public Camel.HeaderAddress @ref ();
		public void set_addr (string addr);
		public void set_members (Camel.HeaderAddress group);
		public void set_name (string name);
		public void unref ();
		[CCode (cname = "camel_header_address_new_name", has_construct_function = false)]
		public HeaderAddress.with_name (string name, string addr);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_index_get_type ()")]
	public class Index : GLib.Object {
		public uint32 flags;
		public weak Camel.IndexNorm normalize;
		public void* normalize_data;
		public weak string path;
		public uint32 state;
		public uint32 version;
		[CCode (has_construct_function = false)]
		protected Index ();
		public virtual unowned Camel.IndexName? add_name (string name);
		public virtual int compress ();
		public void @construct (string path, int flags);
		public int @delete ();
		[NoWrapper]
		public virtual int delete_ ();
		public virtual void delete_name (string name);
		public virtual unowned Camel.IndexCursor? find (string word);
		public virtual unowned Camel.IndexCursor? find_name (string name);
		public virtual int has_name (string name);
		public virtual int rename (string path);
		public void set_normalize (Camel.IndexNorm func);
		public virtual int sync ();
		public virtual unowned Camel.IndexCursor? words ();
		public virtual int write_name (Camel.IndexName idn);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_index_cursor_get_type ()")]
	public class IndexCursor : GLib.Object {
		public weak Camel.Index index;
		[CCode (has_construct_function = false)]
		protected IndexCursor ();
		public virtual unowned string next ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_index_name_get_type ()")]
	public class IndexName : GLib.Object {
		public weak GLib.ByteArray buffer;
		public weak Camel.Index index;
		public weak string name;
		public weak GLib.HashTable<void*,void*> words;
		[CCode (has_construct_function = false)]
		protected IndexName ();
		public virtual size_t add_buffer (string buffer, size_t len);
		public virtual void add_word (string word);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_internet_address_get_type ()")]
	public class InternetAddress : Camel.Address {
		[CCode (has_construct_function = false)]
		public InternetAddress ();
		public int add (string name, string address);
		public static string encode_address (int len, string name, string addr);
		public void ensure_ascii_domains ();
		public int find_address (string address, string namep);
		public int find_name (string name, string addressp);
		public static string format_address (string name, string addr);
		public bool @get (int index, out unowned string namep, out unowned string addressp);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_key_file_get_type ()")]
	public class KeyFile : GLib.Object {
		public int flags;
		public void* fp;
		public int64 last;
		public weak string path;
		[CCode (has_construct_function = false)]
		public KeyFile (string path, int flags, char version);
		public int @delete ();
		public int read (Camel._block_t start, size_t len, Camel._key_t records);
		public int rename (string path);
		public int write (Camel._block_t parent, size_t len, Camel._key_t records);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_key_table_get_type ()")]
	public class KeyTable : GLib.Object {
		public weak Camel.BlockFile blocks;
		public Camel.KeyRootBlock root;
		public Camel.Block root_block;
		public Camel._block_t rootid;
		[CCode (has_construct_function = false)]
		public KeyTable (Camel.BlockFile bs, Camel._block_t root);
		public Camel._key_t add (string key, Camel._block_t data, uint flags);
		public Camel._block_t lookup (Camel._key_t keyid, string key, uint flags);
		public Camel._key_t next (Camel._key_t next, string keyp, uint flagsp, Camel._block_t datap);
		public bool set_data (Camel._key_t keyid, Camel._block_t data);
		public bool set_flags (Camel._key_t keyid, uint flags, uint @set);
		public int sync ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_local_settings_get_type ()")]
	public class LocalSettings : Camel.StoreSettings {
		[CCode (has_construct_function = false)]
		protected LocalSettings ();
		public string dup_path ();
		public unowned string get_path ();
		public void set_path (string path);
		public string path { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_medium_get_type ()")]
	public abstract class Medium : Camel.DataWrapper {
		[CCode (has_construct_function = false)]
		protected Medium ();
		public virtual void add_header (string name, void* value);
		public virtual void free_headers (GLib.Array<Camel.MediumHeader> headers);
		public virtual unowned Camel.DataWrapper? get_content ();
		public virtual void* get_header (string name);
		public virtual GLib.Array<Camel.MediumHeader> get_headers ();
		public virtual void remove_header (string name);
		public virtual void set_content (Camel.DataWrapper content);
		public virtual void set_header (string name, void* value);
		public Camel.DataWrapper content { get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class MemChunk {
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class MemPool {
	}
	[CCode (cheader_filename = "camel/camel.h", ref_function = "camel_message_info_ref", type_id = "camel_message_info_get_type ()", unref_function = "camel_message_info_unref")]
	[Compact]
	public class MessageInfo {
		public uint dirty;
		public int refcount;
		public weak Camel.FolderSummary summary;
		public weak string uid;
		[CCode (has_construct_function = false, type = "gpointer")]
		public MessageInfo (Camel.FolderSummary? summary);
		public Camel.MessageInfo clone ();
		public void dump ();
		[CCode (has_construct_function = false)]
		public MessageInfo.from_header (Camel.FolderSummary summary, void* header);
		[CCode (cname = "camel_message_info_ptr")]
		public void* get_ptr (Camel.MessageInfoField id);
		[CCode (cname = "camel_message_info_time")]
		public time_t get_time (int id);
		[CCode (cname = "camel_message_info_uint32")]
		public uint32 get_uint32 (int id);
		public Camel.MessageInfo @ref ();
		public bool set_flags (Camel.MessageFlags flags, uint32 @set);
		public bool set_user_flag (string id, bool state);
		public bool set_user_tag (string id, string val);
		public void unref ();
		public bool user_flag (string id);
		public unowned string user_tag (string id);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_get_type ()")]
	public abstract class MimeFilter : GLib.Object {
		public weak string backbuf;
		public size_t backlen;
		public size_t backsize;
		public weak string outbuf;
		public size_t outpre;
		public weak string outptr;
		public weak string outreal;
		public size_t outsize;
		[CCode (has_construct_function = false)]
		public MimeFilter ();
		public void backup (string data, size_t length);
		public virtual void complete (string @in, size_t len, size_t prespace, string @out, size_t outlen, size_t outprespace);
		public virtual void filter (string @in, size_t len, size_t prespace, string @out, size_t outlen, size_t outprespace);
		public virtual void reset ();
		public void set_size (size_t size, int keep);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_basic_get_type ()")]
	public class MimeFilterBasic : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterBasic (Camel.MimeFilterBasicType type);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_bestenc_get_type ()")]
	public class MimeFilterBestenc : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterBestenc (uint flags);
		public unowned string get_best_charset ();
		public Camel.TransferEncoding get_best_encoding (Camel.BestencEncoding required);
		public void set_flags (uint flags);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_crlf_get_type ()")]
	public class MimeFilterCRLF : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterCRLF (Camel.MimeFilterCRLFDirection direction, Camel.MimeFilterCRLFMode mode);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_canon_get_type ()")]
	public class MimeFilterCanon : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterCanon (uint32 flags);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_charset_get_type ()")]
	public class MimeFilterCharset : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterCharset (string from_charset, string to_charset);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_enriched_get_type ()")]
	public class MimeFilterEnriched : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterEnriched (uint32 flags);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_from_get_type ()")]
	public class MimeFilterFrom : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterFrom ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_gzip_get_type ()")]
	public class MimeFilterGZip : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterGZip (Camel.MimeFilterGZipMode mode, int level);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_html_get_type ()")]
	public class MimeFilterHTML : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterHTML ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_index_get_type ()")]
	public class MimeFilterIndex : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterIndex (Camel.Index index);
		public void set_index (Camel.Index index);
		public void set_name (Camel.IndexName name);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_linewrap_get_type ()")]
	public class MimeFilterLinewrap : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterLinewrap (uint preferred_len, uint max_len, char indent_char, uint32 flags);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_pgp_get_type ()")]
	public class MimeFilterPgp : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterPgp ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_progress_get_type ()")]
	public class MimeFilterProgress : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterProgress (GLib.Cancellable? cancellable, size_t total);
	}
	[CCode (cheader_filename = "camel/camel.h", lower_case_csuffix = "mime_filter_tohtml", type_id = "camel_mime_filter_tohtml_get_type ()")]
	public class MimeFilterToHTML : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterToHTML (Camel.MimeFilterToHTMLFlags flags, uint32 color);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_windows_get_type ()")]
	public class MimeFilterWindows : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterWindows (string claimed_charset);
		public bool is_windows_charset ();
		public unowned string real_charset ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_filter_yenc_get_type ()")]
	public class MimeFilterYenc : Camel.MimeFilter {
		[CCode (has_construct_function = false, type = "CamelMimeFilter*")]
		public MimeFilterYenc (Camel.MimeFilterYencDirection direction);
		public uint32 get_crc ();
		public uint32 get_pcrc ();
		public void set_crc (uint32 crc);
		public void set_state (int state);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_message_get_type ()")]
	public class MimeMessage : Camel.MimePart {
		public long date;
		public int date_offset;
		public long date_received;
		public int date_received_offset;
		public weak Camel.InternetAddress from;
		public weak string message_id;
		public weak GLib.HashTable<string, Camel.InternetAddress> recipients;
		public weak Camel.InternetAddress reply_to;
		public weak string subject;
		[CCode (has_construct_function = false)]
		public MimeMessage ();
		public string build_mbox_from ();
		public static bool build_preview (Camel.MimePart mime_part, Camel.MessageInfo info);
		public void dump (int body);
		public void encode_8bit_parts ();
		public long get_date (int offset);
		public long get_date_received (int offset);
		public unowned Camel.InternetAddress get_from ();
		public unowned string get_message_id ();
		public unowned Camel.MimePart get_part_by_content_id (string content_id);
		public unowned Camel.InternetAddress get_recipients (string type);
		public unowned Camel.InternetAddress get_reply_to ();
		public unowned string get_source ();
		public unowned string get_subject ();
		public bool has_8bit_parts ();
		public bool has_attachment ();
		public void set_best_encoding (Camel.BestencRequired required, Camel.BestencEncoding enctype);
		public void set_date (long date, int offset);
		public void set_from (Camel.InternetAddress from);
		public void set_message_id (string message_id);
		public void set_recipients (string type, Camel.InternetAddress recipients);
		public void set_reply_to (Camel.InternetAddress reply_to);
		public void set_source (string source_uid);
		public void set_subject (string subject);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_parser_get_type ()")]
	public class MimeParser : GLib.Object {
		[CCode (has_construct_function = false)]
		public MimeParser ();
		[NoWrapper]
		public virtual void content ();
		public Camel.ContentType content_type ();
		public void drop_step ();
		public int errno ();
		public int filter_add (Camel.MimeFilter mf);
		public void filter_remove (int id);
		public unowned string from_line ();
		public unowned string header (string name, int offset);
		public void* headers_raw ();
		public void init_with_bytes (GLib.Bytes bytes);
		public int init_with_fd (int fd);
		public void init_with_input_stream (GLib.InputStream input_stream);
		public int init_with_stream (Camel.Stream stream) throws GLib.Error;
		[NoWrapper]
		public virtual void message (void* headers);
		[NoWrapper]
		public virtual void part ();
		public unowned string postface ();
		public unowned string preface ();
		public void push_state (Camel._mime_parser_state_t newstate, string boundary);
		public ssize_t read (string databuffer, ssize_t len) throws GLib.Error;
		public void scan_from (bool scan_from);
		public void scan_pre_from (bool scan_pre_from);
		public int64 seek (int64 offset, int whence);
		public int set_header_regex (string matchstr);
		public Camel._mime_parser_state_t state ();
		public Camel._mime_parser_state_t step (string databuffer, size_t datalength);
		public unowned Camel.Stream? stream ();
		public int64 tell ();
		public int64 tell_start_boundary ();
		public int64 tell_start_from ();
		public int64 tell_start_headers ();
		public void unstep ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_mime_part_get_type ()")]
	public class MimePart : Camel.Medium {
		public void* headers;
		[CCode (has_construct_function = false)]
		public MimePart ();
		public bool construct_content_from_parser (Camel.MimeParser mp, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool construct_from_parser (Camel.MimeParser parser, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool construct_from_parser_sync (Camel.MimeParser parser, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public unowned Camel.ContentDisposition get_content_disposition ();
		public unowned string get_content_id ();
		public unowned GLib.List<string> get_content_languages ();
		public unowned string get_content_location ();
		public unowned string get_content_md5 ();
		public unowned Camel.ContentType get_content_type ();
		public unowned string get_description ();
		public unowned string get_disposition ();
		public Camel.TransferEncoding get_encoding ();
		public unowned string get_filename ();
		public void set_content (string data, int length, string type);
		public void set_content_id (string contentid);
		public void set_content_languages (GLib.List<string> content_languages);
		public void set_content_location (string location);
		public void set_content_md5 (string md5sum);
		public void set_content_type (string content_type);
		public void set_description (string description);
		public void set_disposition (string disposition);
		public void set_encoding (Camel.TransferEncoding encoding);
		public void set_filename (string filename);
		public string content_id { get; set; }
		public string content_md5 { get; set; }
		public string description { get; set; }
		public string disposition { get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class MsgPort {
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_multipart_get_type ()")]
	public class Multipart : Camel.DataWrapper {
		[CCode (has_construct_function = false)]
		public Multipart ();
		public virtual void add_part (Camel.MimePart part);
		public virtual int construct_from_parser (Camel.MimeParser parser);
		public virtual unowned string get_boundary ();
		public virtual uint get_number ();
		public virtual unowned Camel.MimePart get_part (uint index);
		public unowned string get_postface ();
		public unowned string get_preface ();
		public virtual void set_boundary (string boundary);
		public void set_postface (string postface);
		public void set_preface (string preface);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_multipart_encrypted_get_type ()")]
	public class MultipartEncrypted : Camel.Multipart {
		[CCode (has_construct_function = false)]
		public MultipartEncrypted ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_multipart_signed_get_type ()")]
	public class MultipartSigned : Camel.Multipart {
		[CCode (has_construct_function = false)]
		public MultipartSigned ();
		public Camel.Stream get_content_stream () throws GLib.Error;
		public void set_content_stream (Camel.Stream content_stream);
		public void set_signature (Camel.MimePart signature);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_nntp_address_get_type ()")]
	public class NNTPAddress : Camel.Address {
		[CCode (has_construct_function = false)]
		public NNTPAddress ();
		public int add (string name);
		public bool @get (int index, string namep);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_null_output_stream_get_type ()")]
	public class NullOutputStream : GLib.OutputStream {
		[CCode (has_construct_function = false, type = "GOutputStream*")]
		public NullOutputStream ();
		public size_t get_bytes_written ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_object_get_type ()")]
	public abstract class Object : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Object ();
		public unowned string get_state_filename ();
		public void set_state_filename (string state_filename);
		[NoWrapper]
		public virtual int state_read (void* fp);
		[NoWrapper]
		public virtual int state_write (void* fp);
		public string state_filename { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class ObjectBag {
		public void abort (void* key);
		public void add (void* key, void* object);
		public void destroy ();
		public void* @get (void* key);
		public GLib.GenericArray<GLib.Object> list ();
		public void* peek (void* key);
		public void rekey (void* object, void* new_key);
		public void remove (void* object);
		public void* reserve (void* key);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_offline_folder_get_type ()")]
	public class OfflineFolder : Camel.Folder {
		[CCode (has_construct_function = false)]
		protected OfflineFolder ();
		public async bool downsync (string expression, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool downsync_sync (string expression, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool get_offline_sync ();
		public void set_offline_sync (bool offline_sync);
		public bool offline_sync { get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_offline_settings_get_type ()")]
	public class OfflineSettings : Camel.StoreSettings {
		[CCode (has_construct_function = false)]
		protected OfflineSettings ();
		public bool get_stay_synchronized ();
		public int get_store_changes_interval ();
		public void set_stay_synchronized (bool stay_synchronized);
		public void set_store_changes_interval (int interval);
		public bool stay_synchronized { get; set construct; }
		public int store_changes_interval { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_offline_store_get_type ()")]
	public class OfflineStore : Camel.Store, GLib.Initable {
		[CCode (has_construct_function = false)]
		protected OfflineStore ();
		public bool get_online ();
		public bool prepare_for_offline_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool requires_downsync ();
		public bool set_online_sync (bool online, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool online { get; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_operation_get_type ()")]
	public class Operation : GLib.Cancellable {
		[CCode (has_construct_function = false, type = "GCancellable*")]
		public Operation ();
		public static void cancel_all ();
		public signal void push_message (string object);
		public virtual signal void status (string what, int pc);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_partition_table_get_type ()")]
	public class PartitionTable : GLib.Object {
		public weak Camel.BlockFile blocks;
		//public weak global::is_key is_key;
		public void* is_key_data;
		public weak GLib.Queue partition;
		public Camel._block_t rootid;
		[CCode (has_construct_function = false)]
		public PartitionTable (void* bs, Camel._block_t root);
		public int add (string key, Camel._key_t keyid);
		public Camel._key_t lookup (string key);
		public bool remove (string key);
		public int sync ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sexp_get_type ()")]
	public class SExp : GLib.Object {
		public weak GLib.SList<void*> operators;
		public weak Camel.MemChunk result_chunks;
		public weak GLib.Scanner scanner;
		public weak Camel.MemChunk term_chunks;
		public Camel.SExpTerm tree;
		[CCode (has_construct_function = false)]
		public SExp ();
		public void add_variable (uint scope, string name, Camel.SExpTerm value);
		public static void encode_bool (GLib.StringBuilder string, bool v_bool);
		public static void encode_string (GLib.StringBuilder string, string v_string);
		public bool evaluate_occur_times (long start, long end);
		public void input_file (int fd);
		public void input_text (string text, int len);
		public int parse ();
		public void remove_symbol (uint scope, string name);
		public void result_free (Camel.SExpResult term);
		public void resultv_free (int argc, Camel.SExpResult argv);
		public int set_scope (uint scope);
		public static string to_sql_sexp (string sexp);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_smime_context_get_type ()")]
	public class SMIMEContext : Camel.CipherContext {
		[CCode (has_construct_function = false, type = "CamelCipherContext*")]
		public SMIMEContext (Camel.Session session);
		public uint32 describe_part (void* part);
		public void set_encrypt_key (bool use, string key);
		public void set_sign_mode (Camel._smime_sign_t type);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_get_type ()")]
	public class Sasl : GLib.Object {
		[CCode (has_construct_function = false)]
		public Sasl (string service_name, string mechanism, Camel.Service service);
		public static GLib.List<weak Camel.ServiceAuthType> authtype_list (bool include_plain);
		public async GLib.ByteArray challenge (GLib.ByteArray token, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public async string challenge_base64 (string token, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public string challenge_base64_sync (string token, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual GLib.ByteArray challenge_sync (GLib.ByteArray token, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool get_authenticated ();
		public unowned string get_mechanism ();
		public unowned Camel.Service get_service ();
		public unowned string get_service_name ();
		public void set_authenticated (bool authenticated);
		public async bool try_empty_password (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool try_empty_password_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool authenticated { get; set; }
		public string mechanism { get; construct; }
		public Camel.Service service { get; construct; }
		public string service_name { get; construct; }
		public static Camel.ServiceAuthType * authtype (string mechanism);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_anonymous_get_type ()")]
	public class SaslAnonymous : Camel.Sasl {
		public weak string trace_info;
		public Camel.SaslAnonTraceType type;
		[CCode (has_construct_function = false, type = "CamelSasl*")]
		public SaslAnonymous (Camel.SaslAnonTraceType type, string trace_info);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_cram_md5_get_type ()")]
	public class SaslCramMd5 : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslCramMd5 ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_digest_md5_get_type ()")]
	public class SaslDigestMd5 : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslDigestMd5 ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_gssapi_get_type ()")]
	public class SaslGssapi : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslGssapi ();
		public static bool is_available ();
		public void override_host_and_user (string override_host, string override_user);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_login_get_type ()")]
	public class SaslLogin : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslLogin ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_ntlm_get_type ()")]
	public class SaslNTLM : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslNTLM ();
	}
	[CCode (cheader_filename = "camel/camel.h", lower_case_csuffix = "sasl_popb4smtp", type_id = "camel_sasl_popb4smtp_get_type ()")]
	public class SaslPOPB4SMTP : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslPOPB4SMTP ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_sasl_plain_get_type ()")]
	public class SaslPlain : Camel.Sasl {
		[CCode (has_construct_function = false)]
		protected SaslPlain ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_service_get_type ()")]
	public abstract class Service : Camel.Object, GLib.Initable {
		[CCode (has_construct_function = false)]
		protected Service ();
		public async Camel.AuthenticationResult authenticate (string mechanism, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.AuthenticationResult authenticate_sync (string? mechanism, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool connect (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool connect_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool disconnect (bool clean, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool disconnect_sync (bool clean, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public string dup_display_name ();
		public string dup_password ();
		public static GLib.Quark error_quark ();
		public Camel.ServiceConnectionStatus get_connection_status ();
		public unowned string get_display_name ();
		public virtual string get_name (bool brief);
		public unowned string get_password ();
		public unowned string get_uid ();
		public unowned string get_user_cache_dir ();
		public unowned string get_user_data_dir ();
		public void migrate_files ();
		public Camel.URL new_camel_url ();
		public async GLib.List<weak Camel.ServiceAuthType> query_auth_types (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual GLib.List<weak Camel.ServiceAuthType> query_auth_types_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void queue_task (GLib.Task task, [CCode (scope = "async")] owned GLib.TaskThreadFunc task_func);
		public GLib.ProxyResolver ref_proxy_resolver ();
		public void* ref_session ();
		public Camel.Settings ref_settings ();
		public void set_display_name (string display_name);
		public void set_password (string password);
		public void set_proxy_resolver (GLib.ProxyResolver proxy_resolver);
		public void set_settings (Camel.Settings settings);
		public Camel.ServiceConnectionStatus connection_status { get; }
		public string display_name { get; set construct; }
		public string password { get; set construct; }
		[NoAccessorMethod]
		public void* provider { get; construct; }
		[NoAccessorMethod]
		public GLib.ProxyResolver proxy_resolver { owned get; set; }
		[NoAccessorMethod]
		public Camel.Session session { owned get; construct; }
		[NoAccessorMethod]
		public Camel.Settings settings { owned get; set construct; }
		public string uid { get; construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_session_get_type ()")]
	public class Session : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Session ();
		public virtual Camel.Service add_service (string uid, string protocol, Camel.ProviderType type) throws GLib.Error;
		public async bool authenticate (Camel.Service service, string mechanism, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool authenticate_sync (Camel.Service service, string? mechanism, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual bool forget_password (Camel.Service service, string item) throws GLib.Error;
		public async bool forward_to (Camel.Folder folder, Camel.MimeMessage message, string address, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool forward_to_sync (Camel.Folder folder, Camel.MimeMessage message, string address, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual unowned Camel.FilterDriver get_filter_driver (string type) throws GLib.Error;
		public unowned Camel.JunkFilter get_junk_filter ();
		public unowned GLib.HashTable<string,string> get_junk_headers ();
		public bool get_online ();
		public virtual string get_password (Camel.Service service, string prompt, string item, uint32 flags) throws GLib.Error;
		public unowned string get_user_cache_dir ();
		public unowned string get_user_data_dir ();
		public uint idle_add (int priority, owned GLib.SourceFunc function);
		public GLib.List<Camel.Service> list_services ();
		public virtual bool lookup_addressbook (string name);
		public GLib.MainContext ref_main_context ();
		public Camel.Service ref_service (string uid);
		public Camel.Service ref_service_by_url (Camel.URL url, Camel.ProviderType type);
		public virtual void remove_service (Camel.Service service);
		public void remove_services ();
		public void set_junk_filter (Camel.JunkFilter junk_filter);
		public void set_junk_headers (string headers, string values, int len);
		public void set_online (bool online);
		public void submit_job (string description, owned Camel.SessionCallback callback);
		public virtual Camel.CertTrust trust_prompt (Camel.Service service, GLib.TlsCertificate certificate, GLib.TlsCertificateFlags errors);
		public Camel.JunkFilter junk_filter { get; set; }
		[NoAccessorMethod]
		public GLib.MainContext main_context { owned get; }
		public bool online { get; set construct; }
		[NoAccessorMethod]
		public string user_cache_dir { owned get; set construct; }
		[NoAccessorMethod]
		public string user_data_dir { owned get; set construct; }
		public virtual signal void job_finished (GLib.Cancellable? cancellable, void* error);
		public virtual signal void job_started (GLib.Cancellable? cancellable = null);
		[HasEmitter]
		public virtual signal void user_alert (Camel.Service service, Camel.SessionAlertType type, string message);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_settings_get_type ()")]
	public class Settings : GLib.Object {
		[CCode (has_construct_function = false)]
		protected Settings ();
		public virtual Camel.Settings clone ();
		public virtual bool equal (Camel.Settings settings_b);
		[CCode (cname = "camel_settings_class_list_settings")]
		public class GLib.ParamSpec list_settings (uint n_settings);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_store_get_type ()")]
	public abstract class Store : Camel.Service, GLib.Initable {
		public void* cdb_r;
		public void* cdb_w;
		public Camel.StoreFlags flags;
		public weak Camel.ObjectBag folders;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] later;
		public Camel.StorePermissionFlags mode;
		[CCode (has_construct_function = false)]
		protected Store ();
		public virtual bool can_refresh_folder (Camel.FolderInfo info) throws GLib.Error;
		public async Camel.FolderInfo create_folder (string parent_name, string folder_name, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.FolderInfo create_folder_sync (string parent_name, string folder_name, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool delete_folder (string folder_name, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool delete_folder_sync (string folder_name, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public static GLib.Quark error_quark ();
		public async Camel.Folder get_folder (string folder_name, Camel.StoreGetFolderFlags flags, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public async Camel.FolderInfo get_folder_info (string top, Camel.StoreGetFolderInfoFlags flags, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.FolderInfo get_folder_info_sync (string? top, Camel.StoreGetFolderInfoFlags flags, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual Camel.Folder get_folder_sync (string folder_name, Camel.StoreGetFolderFlags flags, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async Camel.Folder get_inbox_folder (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.Folder get_inbox_folder_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async Camel.Folder get_junk_folder (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.Folder get_junk_folder_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async Camel.Folder get_trash_folder (int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual Camel.Folder get_trash_folder_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool initial_setup (int io_priority, GLib.Cancellable? cancellable, out GLib.HashTable<weak string,weak string> out_save_setup) throws GLib.Error;
		public virtual bool initial_setup_sync (out GLib.HashTable<weak string,weak string> out_save_setup, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public bool maybe_run_db_maintenance () throws GLib.Error;
		public async bool rename_folder (string old_name, string new_name, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool rename_folder_sync (string old_name, string new_name, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool synchronize (bool expunge, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public virtual bool synchronize_sync (bool expunge, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[HasEmitter]
		public virtual signal void folder_created (void* folder_info);
		[HasEmitter]
		public virtual signal void folder_deleted (void* folder_info);
		[HasEmitter]
		public virtual signal void folder_info_stale ();
		[HasEmitter]
		public virtual signal void folder_opened (Camel.Folder folder);
		[HasEmitter]
		public virtual signal void folder_renamed (string old_name, void* folder_info);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_store_settings_get_type ()")]
	public class StoreSettings : Camel.Settings {
		[CCode (has_construct_function = false)]
		protected StoreSettings ();
		public bool get_filter_inbox ();
		public void set_filter_inbox (bool filter_inbox);
		public bool filter_inbox { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_store_summary_get_type ()")]
	public class StoreSummary : GLib.Object {
		public weak GLib.GenericArray<void*> folders;
		public weak GLib.HashTable<void*,void*> folders_path;
		[CCode (has_construct_function = false)]
		public StoreSummary ();
		public void add (Camel.StoreInfo info);
		public GLib.GenericArray<Camel.StoreInfo> array ();
		public void array_free (GLib.GenericArray<Camel.StoreInfo> array);
		public bool connect_folder_summary (string path, void* folder_summary);
		public int count ();
		public bool disconnect_folder_summary (void* folder_summary);
		public void info_unref (Camel.StoreInfo info);
		public int load ();
		public void remove (Camel.StoreInfo info);
		public void remove_path (string path);
		public int save ();
		public void set_filename (string filename);
		[NoWrapper]
		public virtual void store_info_free (Camel.StoreInfo info);
		[NoWrapper]
		public virtual int store_info_save (void* file, Camel.StoreInfo info);
		[NoWrapper]
		public virtual void store_info_set_string (Camel.StoreInfo info, int type, string value);
		[NoWrapper]
		public virtual int summary_header_load (void* file);
		[NoWrapper]
		public virtual int summary_header_save (void* file);
		public void touch ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_get_type ()")]
	public class Stream : GLib.Object, GLib.Seekable {
		[CCode (has_construct_function = false)]
		public Stream (GLib.IOStream base_stream);
		public virtual int close (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual int flush (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public virtual ssize_t read (string buffer, size_t n, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public GLib.IOStream? ref_base_stream ();
		public void set_base_stream (GLib.IOStream base_stream);
		public virtual ssize_t write (string buffer, size_t n, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public ssize_t write_string (string string, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public ssize_t write_to_stream (Camel.Stream output_stream, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[NoAccessorMethod]
		public GLib.IOStream base_stream { owned get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_buffer_get_type ()")]
	public class StreamBuffer : Camel.Stream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamBuffer (Camel.Stream stream, Camel.StreamBufferMode mode);
		public int gets (string buf, uint max, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[NoWrapper]
		public virtual void init (Camel.Stream stream, Camel.StreamBufferMode mode);
		[NoWrapper]
		public virtual void init_vbuf (Camel.Stream stream, Camel.StreamBufferMode mode, string buf, uint32 size);
		public string read_line (GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_filter_get_type ()")]
	public class StreamFilter : Camel.Stream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamFilter (Camel.Stream source);
		public int add (Camel.MimeFilter filter);
		public unowned Camel.Stream get_source ();
		public void remove (int id);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_fs_get_type ()")]
	public class StreamFs : Camel.Stream, GLib.Seekable {
		[CCode (has_construct_function = false)]
		protected StreamFs ();
		public int get_fd ();
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamFs.with_fd (int fd);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_mem_get_type ()")]
	public class StreamMem : Camel.Stream, GLib.Seekable {
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamMem ();
		public unowned GLib.ByteArray get_byte_array ();
		public void set_buffer (string buffer, size_t len);
		public void set_byte_array (GLib.ByteArray buffer);
		public void set_secure ();
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamMem.with_buffer (string buffer, size_t len);
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamMem.with_byte_array (GLib.ByteArray buffer);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_null_get_type ()")]
	public class StreamNull : Camel.Stream, GLib.Seekable {
		public size_t written;
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamNull ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_stream_process_get_type ()")]
	public class StreamProcess : Camel.Stream, GLib.Seekable {
		public int childpid;
		public int sockfd;
		[CCode (has_construct_function = false, type = "CamelStream*")]
		public StreamProcess ();
		public int connect (string command, string env) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_text_index_get_type ()")]
	public class TextIndex : Camel.Index {
		[CCode (has_construct_function = false)]
		public TextIndex (string path, int flags);
		public static int check (string path);
		public void dump ();
		public void info ();
		public static int remove (string old);
		public static int rename (string old, string new_);
		public void validate ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_text_index_cursor_get_type ()")]
	public class TextIndexCursor : Camel.IndexCursor {
		[CCode (has_construct_function = false)]
		protected TextIndexCursor ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_text_index_key_cursor_get_type ()")]
	public class TextIndexKeyCursor : Camel.IndexCursor {
		[CCode (has_construct_function = false)]
		protected TextIndexKeyCursor ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_text_index_name_get_type ()")]
	public class TextIndexName : Camel.IndexName {
		[CCode (has_construct_function = false)]
		protected TextIndexName ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_transport_get_type ()")]
	public abstract class Transport : Camel.Service, GLib.Initable {
		[CCode (has_construct_function = false)]
		protected Transport ();
		public async bool send_to (Camel.MimeMessage message, Camel.Address from, Camel.Address recipients, int io_priority, GLib.Cancellable? cancellable, out bool out_sent_message_saved) throws GLib.Error;
		public virtual bool send_to_sync (Camel.MimeMessage message, Camel.Address from, Camel.Address recipients, out bool out_sent_message_saved, GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class Trie {
		public void add (string pattern, int pattern_id);
		public void free ();
		public unowned string search (string buffer, size_t buflen, int matched_id);
	}
	[CCode (cheader_filename = "camel/camel.h", copy_function = "g_boxed_copy", free_function = "g_boxed_free", type_id = "camel_url_get_type ()")]
	[Compact]
	public class URL {
		public weak string authmech;
		public weak string fragment;
		public weak string host;
		public GLib.Datalist @params;
		public weak string path;
		public int port;
		public weak string protocol;
		public weak string query;
		public weak string user;
		[CCode (has_construct_function = false)]
		public URL (string url_string) throws GLib.Error;
		public static bool addrspec_end (string @in, string pos, string inend, Camel.UrlMatch match);
		public static bool addrspec_start (string @in, string pos, string inend, Camel.UrlMatch match);
		public Camel.URL copy ();
		public static void decode (string part);
		public static string decode_path (string path);
		public static string encode (string part, string escape_extra);
		public static int equal (void* v, void* v2);
		public static bool file_end (string @in, string pos, string inend, Camel.UrlMatch match);
		public static bool file_start (string @in, string pos, string inend, Camel.UrlMatch match);
		public void free ();
		public unowned string get_param (string name);
		public static uint hash (void* v);
		public Camel.URL new_with_base (string url_string);
		public void set_authmech (string authmech);
		public void set_fragment (string fragment);
		public void set_host (string host);
		public void set_param (string name, string value);
		public void set_path (string path);
		public void set_port (int port);
		public void set_protocol (string protocol);
		public void set_query (string query);
		public void set_user (string user);
		public string to_string (Camel.URLFlags flags);
		public static bool web_end (string @in, string pos, string inend, Camel.UrlMatch match);
		public static bool web_start (string @in, string pos, string inend, Camel.UrlMatch match);
	}
	[CCode (cheader_filename = "camel/camel.h")]
	[Compact]
	public class UrlScanner {
		public void add (Camel.UrlPattern pattern);
		public void free ();
		public bool scan (string @in, size_t inlen, Camel.UrlMatch match);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vtrash_folder_get_type ()")]
	public class VTrashFolder : Camel.VeeFolder {
		public uint32 bit;
		public Camel._vtrash_folder_t type;
		[CCode (has_construct_function = false, type = "CamelFolder*")]
		public VTrashFolder (Camel.Store parent_store, Camel._vtrash_folder_t type);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_data_cache_get_type ()")]
	public class VeeDataCache : GLib.Object {
		[CCode (has_construct_function = false)]
		public VeeDataCache ();
		public void add_subfolder (Camel.Folder subfolder);
		public bool contains_message_info_data (Camel.Folder folder, string orig_message_uid);
		public void foreach_message_info_data (Camel.Folder fromfolder, void* func);
		public Camel.VeeMessageInfoData get_message_info_data (Camel.Folder folder, string orig_message_uid);
		public Camel.VeeMessageInfoData get_message_info_data_by_vuid (string vee_message_uid);
		public Camel.VeeSubfolderData get_subfolder_data (Camel.Folder folder);
		public void remove_message_info_data (Camel.VeeMessageInfoData mi_data);
		public void remove_subfolder (Camel.Folder subfolder);
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_folder_get_type ()")]
	public class VeeFolder : Camel.Folder {
		public uint32 flags;
		[CCode (has_construct_function = false, type = "CamelFolder*")]
		public VeeFolder (Camel.Store parent_store, string full, uint32 flags);
		public virtual void add_folder (Camel.Folder subfolder, GLib.Cancellable? cancellable = null);
		public void add_vuid (void* mi_data, Camel.FolderChangeInfo changes);
		public void @construct (uint32 flags);
		[NoWrapper]
		public virtual void folder_changed (Camel.Folder subfolder, Camel.FolderChangeInfo changes);
		public bool get_auto_update ();
		public unowned string get_expression ();
		public unowned Camel.Folder get_location (void* vinfo, string realuid);
		public unowned Camel.Folder get_vee_uid_folder (string vee_message_uid);
		public void ignore_next_changed_event (Camel.Folder subfolder);
		public virtual void rebuild_folder (Camel.Folder subfolder, GLib.Cancellable? cancellable = null);
		public virtual void remove_folder (Camel.Folder subfolder, GLib.Cancellable? cancellable = null);
		public void remove_from_ignore_changed_event (Camel.Folder subfolder);
		public void remove_vuid (void* mi_data, Camel.FolderChangeInfo changes);
		public void set_auto_update (bool auto_update);
		public virtual void set_expression (string expression);
		public void set_folders (GLib.List<Camel.Folder> folders, GLib.Cancellable? cancellable = null);
		public bool auto_update { get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_message_info_data_get_type ()")]
	public class VeeMessageInfoData : GLib.Object {
		[CCode (has_construct_function = false)]
		public VeeMessageInfoData (Camel.VeeSubfolderData subfolder_data, string orig_message_uid);
		public unowned string get_orig_message_uid ();
		public unowned Camel.VeeSubfolderData get_subfolder_data ();
		public unowned string get_vee_message_uid ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_store_get_type ()")]
	public class VeeStore : Camel.Store, GLib.Initable {
		[CCode (has_construct_function = false)]
		public VeeStore ();
		public bool get_unmatched_enabled ();
		public void* get_unmatched_folder ();
		public unowned Camel.VeeDataCache get_vee_data_cache ();
		public void note_subfolder_unused (Camel.Folder subfolder, void* unused_by);
		public void note_subfolder_used (Camel.Folder subfolder, void* used_by);
		public void note_vuid_unused (Camel.VeeMessageInfoData mi_data, void* unused_by);
		public void note_vuid_used (Camel.VeeMessageInfoData mi_data, void* used_by);
		public void rebuild_unmatched_folder (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public void set_unmatched_enabled (bool is_enabled);
		public bool unmatched_enabled { get; set; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_subfolder_data_get_type ()")]
	public class VeeSubfolderData : GLib.Object {
		[CCode (has_construct_function = false)]
		public VeeSubfolderData (Camel.Folder folder);
		public unowned Camel.Folder get_folder ();
		public unowned string get_folder_id ();
	}
	[CCode (cheader_filename = "camel/camel.h", type_id = "camel_vee_summary_get_type ()")]
	public class VeeSummary : Camel.FolderSummary {
		[CCode (has_construct_function = false, type = "CamelFolderSummary*")]
		public VeeSummary (void* parent);
		public GLib.HashTable<weak string,weak string> get_uids_for_subfolder (Camel.Folder subfolder);
		public void remove (string vuid, Camel.Folder subfolder);
		public void replace_flags (string uid);
	}
	[CCode (cheader_filename = "camel/camel.h", type_cname = "CamelJunkFilterInterface", type_id = "camel_junk_filter_get_type ()")]
	public interface JunkFilter : GLib.Object {
		public abstract Camel.JunkStatus classify (Camel.MimeMessage message, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract bool learn_junk (Camel.MimeMessage message, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract bool learn_not_junk (Camel.MimeMessage message, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract bool synchronize (GLib.Cancellable? cancellable = null) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h", type_cname = "CamelNetworkServiceInterface", type_id = "camel_network_service_get_type ()")]
	public interface NetworkService : Camel.Service {
		public async bool can_reach (GLib.Cancellable? cancellable) throws GLib.Error;
		public bool can_reach_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract GLib.IOStream connect_sync (GLib.Cancellable? cancellable = null) throws GLib.Error;
		public abstract uint16 get_default_port (Camel.NetworkSecurityMethod method);
		public bool get_host_reachable ();
		public abstract unowned string get_service_name (Camel.NetworkSecurityMethod method);
		public GLib.SocketConnectable ref_connectable ();
		public void set_connectable (GLib.SocketConnectable connectable);
		public GLib.IOStream starttls (GLib.IOStream base_stream) throws GLib.Error;
		[NoAccessorMethod]
		public abstract GLib.SocketConnectable connectable { owned get; set; }
		[ConcreteAccessor]
		public abstract bool host_reachable { get; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_cname = "CamelNetworkSettingsInterface", type_id = "camel_network_settings_get_type ()")]
	public interface NetworkSettings : Camel.Settings {
		public string dup_auth_mechanism ();
		public string dup_host ();
		public string dup_host_ensure_ascii ();
		public string dup_user ();
		public unowned string get_auth_mechanism ();
		public unowned string get_host ();
		public uint16 get_port ();
		public Camel.NetworkSecurityMethod get_security_method ();
		public unowned string get_user ();
		public void set_auth_mechanism (string auth_mechanism);
		public void set_host (string host);
		public void set_port (uint16 port);
		public void set_security_method (Camel.NetworkSecurityMethod method);
		public void set_user (string user);
		[ConcreteAccessor]
		public abstract string auth_mechanism { get; set construct; }
		[ConcreteAccessor]
		public abstract string host { get; set construct; }
		[ConcreteAccessor]
		public abstract uint port { get; set construct; }
		[ConcreteAccessor]
		public abstract Camel.NetworkSecurityMethod security_method { get; set construct; }
		[ConcreteAccessor]
		public abstract string user { get; set construct; }
	}
	[CCode (cheader_filename = "camel/camel.h", type_cname = "CamelSubscribableInterface", type_id = "camel_subscribable_get_type ()")]
	public interface Subscribable : Camel.Store {
		public abstract bool folder_is_subscribed (string folder_name);
		public async bool subscribe_folder (string folder_name, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public abstract bool subscribe_folder_sync (string folder_name, GLib.Cancellable? cancellable = null) throws GLib.Error;
		public async bool unsubscribe_folder (string folder_name, int io_priority, GLib.Cancellable? cancellable) throws GLib.Error;
		public abstract bool unsubscribe_folder_sync (string folder_name, GLib.Cancellable? cancellable = null) throws GLib.Error;
		[HasEmitter]
		public virtual signal void folder_subscribed (void* folder_info);
		[HasEmitter]
		public virtual signal void folder_unsubscribed (void* folder_info);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Block {
		public Camel._block_t id;
		public Camel.BlockFlags flags;
		public uint32 refcount;
		public uint32 align00;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak uint8[] data;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct BlockRoot {
		[CCode (array_length = false, array_null_terminated = true)]
		public weak char[] version;
		public uint32 flags;
		public uint32 block_size;
		public Camel._block_t free;
		public Camel._block_t last;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Charset {
		public uint mask;
		public int level;
		public static unowned string best (string @in, int len);
		public unowned string best_name ();
		public void init ();
		public static unowned string iso_to_windows (string isocharset);
		public void step (string @in, int len);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct CipherCertInfo {
		public weak string name;
		public weak string email;
		public void* cert_data;
		//public weak global::cert_data_free cert_data_free;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct DB {
		public weak GLib.Mutex @lock;
		public int abort_transaction () throws GLib.Error;
		public int add_to_transaction (string query) throws GLib.Error;
		public int begin_transaction () throws GLib.Error;
		public static void camel_mir_free (Camel.MIRecord record);
		public int clear_folder_summary (string folder) throws GLib.Error;
		public void close ();
		public int command (string stmt) throws GLib.Error;
		public int count_deleted_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_junk_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_junk_not_deleted_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_message_info (string query, uint32 count) throws GLib.Error;
		public int count_total_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_unread_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_visible_message_info (string table_name, uint32 count) throws GLib.Error;
		public int count_visible_unread_message_info (string table_name, uint32 count) throws GLib.Error;
		public int create_folders_table () throws GLib.Error;
		public int delete_folder (string folder) throws GLib.Error;
		public int delete_uid (string folder, string uid) throws GLib.Error;
		public int delete_uids (string folder_name, GLib.List<string> uids) throws GLib.Error;
		public int end_transaction () throws GLib.Error;
		public int flush_in_memory_transactions (string folder_name) throws GLib.Error;
		public static void free_sqlized_string (string string);
		public static Camel.DBKnownColumnNames get_column_ident (GLib.HashTable<void*,void*> hash, int index, int ncols, string col_names);
		public static string get_column_name (string raw_name);
		public GLib.GenericArray<string> get_folder_deleted_uids (string folder_name) throws GLib.Error;
		public GLib.GenericArray<string> get_folder_junk_uids (string folder_name) throws GLib.Error;
		public GLib.HashTable<string,string> get_folder_preview (string folder_name) throws GLib.Error;
		public int get_folder_uids (string folder_name, string sort_by, string collate, GLib.HashTable<void*,void*> hash) throws GLib.Error;
		public bool maybe_run_maintenance () throws GLib.Error;
		public int prepare_message_info_table (string folder_name) throws GLib.Error;
		public int read_folder_info_record (string folder_name, Camel.FIRecord record) throws GLib.Error;
		public int read_message_info_record_with_uid (string folder_name, string uid, [CCode (delegate_target_pos = 2.5, scope = "async")] owned Camel.DBSelectCB read_mir_callback) throws GLib.Error;
		public int read_message_info_records (string folder_name, [CCode (delegate_target_pos = 1.5, scope = "async")] owned Camel.DBSelectCB read_mir_callback) throws GLib.Error;
		public int rename_folder (string old_folder, string new_folder) throws GLib.Error;
		public int reset_folder_version (string folder_name, int reset_version) throws GLib.Error;
		public int select (string stmt, [CCode (scope = "async")] owned Camel.DBSelectCB callback) throws GLib.Error;
		public int set_collate (string col, string collate, Camel.DBCollate func);
		public static string sqlize_string (string string);
		public int start_in_memory_transactions () throws GLib.Error;
		public int transaction_command (GLib.List<string> qry_list) throws GLib.Error;
		public int write_folder_info_record (Camel.FIRecord record) throws GLib.Error;
		public int write_fresh_message_info_record (string folder_name, Camel.MIRecord record) throws GLib.Error;
		public int write_message_info_record (string folder_name, Camel.MIRecord record) throws GLib.Error;
		public int write_preview_record (string folder_name, string uid, string msg) throws GLib.Error;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct FIRecord {
		public weak string folder_name;
		public uint32 version;
		public uint32 flags;
		public uint32 nextuid;
		public long time;
		public uint32 saved_count;
		public uint32 unread_count;
		public uint32 deleted_count;
		public uint32 junk_count;
		public uint32 visible_count;
		public uint32 jnd_count;
		public weak string bdata;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Flag {
		public void* next;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak char[] name;
		public static bool @get (Camel.Flag list, string name);
		public static bool list_copy (Camel.Flag to, Camel.Flag from);
		public static void list_free (Camel.Flag list);
		public static int list_size (Camel.Flag list);
		public static bool @set (Camel.Flag list, string name, bool value);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct FolderChangeInfo {
		public weak GLib.GenericArray<void*> uid_added;
		public weak GLib.GenericArray<void*> uid_removed;
		public weak GLib.GenericArray<void*> uid_changed;
		public weak GLib.GenericArray<void*> uid_recent;
		public void add_source (string uid);
		public void add_source_list (owned GLib.GenericArray<weak string> list);
		public void add_uid (string uid);
		public void add_update (string uid);
		public void add_update_list (owned GLib.GenericArray<weak string> list);
		public void build_diff ();
		public void cat (Camel.FolderChangeInfo src);
		public void change_uid (string uid);
		public bool changed ();
		public void clear ();
		public void free ();
		public void recent_uid (string uid);
		public void remove_uid (string uid);
	}

	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public class FolderThread {
		public FolderThread (Camel.Folder folder, GLib.GenericArray uids, bool thread_subject);
		[CCode (cname = "camel_folder_thread_new_summary")]
		public FolderThread.with_summary (GLib.GenericArray summary);
		public uint32 refcount;
		public uint32 subject;
		public Camel.FolderThreadNode* tree;
		public weak Camel.MemChunk node_chunks;
		public weak Camel.Folder folder;
		public weak GLib.GenericArray<void*> summary;
		public void apply (GLib.GenericArray<string> uids);
		public void ref ();
		public void unref ();
		public static int dump (Camel.FolderThreadNode node);
	}

	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct FolderThreadNode {
		public void* next;
		public void* parent;
		public void* child;
		public weak Camel.MessageInfo message;
		public weak string root_subject;
		public uint32 order;
		public uint32 re;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct HeaderParam {
		public void* next;
		public weak string name;
		public weak string value;
		public static void* list_decode (string @in);
		public static string list_format (void* @params);
		public static void list_format_append (GLib.StringBuilder @out, void* @params);
		public static void list_free (void* @params);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct KeyBlock {
		public Camel._block_t next;
		public uint32 used;
		[CCode (array_length = false, array_null_terminated = true, cname = "u.keys")]
		public weak void*[] u_keys;
		[CCode (array_length = false, array_null_terminated = true, cname = "u.keydata")]
		public weak char[] u_keydata;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct KeyRootBlock {
		public Camel._block_t first;
		public Camel._block_t last;
		public Camel._key_t free;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct MIRecord {
		public weak string uid;
		public uint32 flags;
		public uint32 msg_type;
		public uint32 dirty;
		public bool read;
		public bool deleted;
		public bool replied;
		public bool important;
		public bool junk;
		public bool attachment;
		public uint32 size;
		public long dsent;
		public long dreceived;
		public weak string subject;
		public weak string from;
		public weak string to;
		public weak string cc;
		public weak string mlist;
		public weak string followup_flag;
		public weak string followup_completed_on;
		public weak string followup_due_by;
		public weak string part;
		public weak string labels;
		public weak string usertags;
		public weak string cinfo;
		public weak string bdata;
		public weak string bodystructure;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct MediumHeader {
		public weak string name;
		public weak string value;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct MessageContentInfo {
		public void* next;
		public void* childs;
		public void* parent;
		public weak Camel.ContentType type;
		public weak string id;
		public weak string description;
		public weak string encoding;
		public uint32 size;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct MessageInfoBase {
		public weak Camel.FolderSummary summary;
		public int refcount;
		public weak string uid;
		public uint dirty;
		public weak string subject;
		public weak string from;
		public weak string to;
		public weak string cc;
		public weak string mlist;
		public Camel.MessageFlags flags;
		public uint32 size;
		public long date_sent;
		public long date_received;
		public Camel.SummaryMessageID message_id;
		public Camel.SummaryReferences references;
		public void* user_flags;
		public void* user_tags;
		public Camel.MessageContentInfo content;
		public void* headers;
		public weak string preview;
		public weak string bodystructure;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Msg {
		public weak Camel.MsgPort reply_port;
		public int flags;
		[CCode (cname = "camel_msgport_reply")]
		public void ort_reply ();
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct PartitionKey {
		public Camel._hash_t hashid;
		public Camel._key_t keyid;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct PartitionKeyBlock {
		public uint32 used;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] keys;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct PartitionMap {
		public Camel._hash_t hashid;
		public Camel._block_t blockid;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct PartitionMapBlock {
		public Camel._block_t next;
		public uint32 used;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak void*[] partition;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Provider {
		public weak string protocol;
		public weak string name;
		public weak string description;
		public weak string domain;
		public Camel.ProviderFlags flags;
		public Camel.ProviderURLFlags url_flags;
		public Camel.ProviderConfEntry extra_conf;
		public Camel.ProviderPortEntry port_entries;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak GLib.Type[] object_types;
		public weak GLib.List<void*> authtypes;
		public weak GLib.HashFunc url_hash;
		public weak GLib.EqualFunc url_equal;
		public weak string translation_domain;
		public int auto_detect (Camel.URL url, ref GLib.HashTable<void*,void*> auto_detected) throws GLib.Error;
		public static void init ();
		public static GLib.List<weak Camel.Provider?> list (bool load);
		public static bool load (string path) throws GLib.Error;
		public void register ();
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct ProviderConfEntry {
		public Camel.ProviderConfType type;
		public weak string name;
		public weak string depname;
		public weak string text;
		public weak string value;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct ProviderModule {
		public weak string path;
		public weak GLib.SList<void*> types;
		public uint loaded;
		public static void init ();
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct ProviderPortEntry {
		public int port;
		public weak string desc;
		public bool is_ssl;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct SExpResult {
		public Camel.SExpResultType type;
		public bool time_generator;
		public long occuring_start;
		public long occuring_end;
		[CCode (cname = "value.ptrarray")]
		public weak GLib.GenericArray<void*> value_ptrarray;
		[CCode (cname = "value.number")]
		public int value_number;
		[CCode (cname = "value.string")]
		public weak string value_string;
		[CCode (cname = "value.boolean")]
		public int value_boolean;
		[CCode (cname = "value.time")]
		public long value_time;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct SExpSymbol {
		public int type;
		public weak string name;
		public void* data;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct SExpTerm {
		public Camel.SExpTermType type;
		[CCode (cname = "value.string")]
		public weak string value_string;
		[CCode (cname = "value.number")]
		public int value_number;
		[CCode (cname = "value.boolean")]
		public int value_boolean;
		[CCode (cname = "value.time")]
		public long value_time;
		[CCode (cname = "value.var")]
		public Camel.SExpSymbol value_var;
		[CCode (cname = "value.func.sym")]
		public Camel.SExpSymbol value_func_sym;
		[CCode (array_length = false, array_null_terminated = true, cname = "value.func.terms")]
		public void*[] value_func_terms;
		[CCode (cname = "value.func.termcount")]
		public int value_func_termcount;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct ServiceAuthType {
		public weak string name;
		public weak string description;
		public weak string authproto;
		public bool need_password;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct StoreInfo {
		public int refcount;
		public weak string path;
		public uint32 flags;
		public uint32 unread;
		public uint32 total;
		public static unowned string name (Camel.StoreSummary summary, Camel.StoreInfo info);
		public static void set_string (Camel.StoreSummary summary, Camel.StoreInfo info, int type, string value);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct SummaryMessageID {
		[CCode (cname = "id.id")]
		public uint64 id_id;
		[CCode (array_length = false, array_null_terminated = true, cname = "id.hash")]
		public weak uint8[] id_hash;
		[CCode (cname = "id.part.hi")]
		public uint32 id_part_hi;
		[CCode (cname = "id.part.lo")]
		public uint32 id_part_lo;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct SummaryReferences {
		public int size;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak Camel.SummaryMessageID[] references;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct Tag {
		public void* next;
		public weak string value;
		[CCode (array_length = false, array_null_terminated = true)]
		public weak char[] name;
		public static unowned string @get (Camel.Tag list, string name);
		public static bool list_copy (Camel.Tag to, Camel.Tag from);
		public static void list_free (Camel.Tag list);
		public static int list_size (Camel.Tag list);
		public static bool @set (Camel.Tag list, string name, string value);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct UIDCache {
		public weak string filename;
		public weak GLib.HashTable<void*,void*> uids;
		public uint level;
		public size_t expired;
		public size_t size;
		public int fd;
		public void destroy ();
		public static void free_uids (owned GLib.GenericArray<string> uids);
		public GLib.GenericArray<string> get_new_uids (GLib.GenericArray<string> uids);
		public bool save ();
		public void save_uid (string uid);
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct UrlMatch {
		public weak string pattern;
		public weak string prefix;
		public int64 um_so;
		public int64 um_eo;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct UrlPattern {
		public weak string pattern;
		public weak string prefix;
		public weak Camel.UrlScanFunc start;
		public weak Camel.UrlScanFunc end;
	}
	[CCode (cheader_filename = "camel/camel.h", has_type_id = false)]
	public struct VeeMessageInfo {
		public Camel.MessageInfoBase info;
		public weak Camel.FolderSummary orig_summary;
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "_CamelKeyKey", has_type_id = false)]
	public struct _KeyKey {
		public Camel._block_t data;
		public uint offset;
		public uint flags;
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "_CamelLockHelperMsg", has_type_id = false)]
	public struct _LockHelperMsg {
		public uint32 magic;
		public uint32 seq;
		public uint32 id;
		public uint32 data;
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "_camel_header_raw", has_type_id = false)]
	public struct __header_raw {
		public void* next;
		public weak string name;
		public weak string value;
		public int offset;
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_block_t")]
	[SimpleType]
	public struct _block_t : uint32 {
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_hash_t")]
	[SimpleType]
	public struct _hash_t : uint32 {
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_key_t")]
	[SimpleType]
	public struct _key_t : uint32 {
	}
	
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_AUTHENTICATION_", type_id = "camel_authentication_result_get_type ()")]
	public enum AuthenticationResult {
		ERROR,
		ACCEPTED,
		REJECTED
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_BESTENC_", has_type_id = false)]
	[Flags]
	public enum BestencEncoding {
		@7BIT,
		@8BIT,
		BINARY,
		TEXT
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_BESTENC_", has_type_id = false)]
	[Flags]
	public enum BestencRequired {
		GET_ENCODING,
		GET_CHARSET,
		LF_IS_CRLF,
		NO_FROM
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_BLOCK_FILE_", has_type_id = false)]
	[Flags]
	public enum BlockFileFlags {
		[CCode (cname = "CAMEL_BLOCK_FILE_SYNC")]
		BLOCK_FILE_SYNC
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_BLOCK_", has_type_id = false)]
	[Flags]
	public enum BlockFlags {
		DIRTY,
		DETACHED
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_CERT_TRUST_", has_type_id = false)]
	public enum CertTrust {
		UNKNOWN,
		NEVER,
		MARGINAL,
		FULLY,
		ULTIMATE,
		TEMPORARY
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_CIPHER_HASH_", has_type_id = false)]
	public enum CipherHash {
		DEFAULT,
		MD2,
		MD5,
		SHA1,
		SHA256,
		SHA384,
		SHA512,
		RIPEMD160,
		TIGER192,
		HAVAL5160
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_DB_COLUMN_", has_type_id = false)]
	public enum DBKnownColumnNames {
		UNKNOWN,
		ATTACHMENT,
		BDATA,
		BODYSTRUCTURE,
		CINFO,
		DELETED,
		DELETED_COUNT,
		DRECEIVED,
		DSENT,
		FLAGS,
		FOLDER_NAME,
		FOLLOWUP_COMPLETED_ON,
		FOLLOWUP_DUE_BY,
		FOLLOWUP_FLAG,
		IMPORTANT,
		JND_COUNT,
		JUNK,
		JUNK_COUNT,
		LABELS,
		MAIL_CC,
		MAIL_FROM,
		MAIL_TO,
		MLIST,
		NEXTUID,
		PART,
		PREVIEW,
		READ,
		REPLIED,
		SAVED_COUNT,
		SIZE,
		SUBJECT,
		TIME,
		UID,
		UNREAD_COUNT,
		USERTAGS,
		VERSION,
		VISIBLE_COUNT,
		VUID
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FETCH_HEADERS_", type_id = "camel_fetch_headers_type_get_type ()")]
	public enum FetchHeadersType {
		BASIC,
		BASIC_AND_MAILING_LIST,
		ALL
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FETCH_", has_type_id = false)]
	public enum FetchType {
		OLD_MESSAGES,
		NEW_MESSAGES
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FOLDER_ERROR_", has_type_id = false)]
	public enum FolderError {
		INVALID,
		INVALID_STATE,
		NON_EMPTY,
		NON_UID,
		INSUFFICIENT_PERMISSION,
		INVALID_PATH,
		INVALID_UID,
		SUMMARY_INVALID
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FOLDER_", type_id = "camel_folder_flags_get_type ()")]
	[Flags]
	public enum FolderFlags {
		HAS_SUMMARY_CAPABILITY,
		FILTER_RECENT,
		HAS_BEEN_DELETED,
		IS_TRASH,
		IS_JUNK,
		FILTER_JUNK
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FOLDER_", type_id = "camel_folder_info_flags_get_type ()")]
	[Flags]
	public enum FolderInfoFlags {
		NOSELECT,
		NOINFERIORS,
		CHILDREN,
		NOCHILDREN,
		SUBSCRIBED,
		VIRTUAL,
		SYSTEM,
		VTRASH,
		SHARED_TO_ME,
		SHARED_BY_ME,
		READONLY,
		TYPE_NORMAL,
		TYPE_INBOX,
		TYPE_OUTBOX,
		TYPE_TRASH,
		TYPE_JUNK,
		TYPE_SENT,
		TYPE_CONTACTS,
		TYPE_EVENTS,
		TYPE_MEMOS,
		TYPE_TASKS,
		TYPE_FLAGGED,
		TYPE_ALL,
		TYPE_ARCHIVE,
		TYPE_DRAFTS
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_FOLDER_SUMMARY_", has_type_id = false)]
	[Flags]
	public enum FolderSummaryFlags {
		DIRTY,
		IN_MEMORY_ONLY
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_JUNK_STATUS_", type_id = "camel_junk_status_get_type ()")]
	public enum JunkStatus {
		ERROR,
		INCONCLUSIVE,
		MESSAGE_IS_JUNK,
		MESSAGE_IS_NOT_JUNK
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_LOCK_", has_type_id = false)]
	public enum LockType {
		READ,
		WRITE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MEMPOOL_ALIGN_", has_type_id = false)]
	public enum MemPoolFlags {
		STRUCT,
		WORD,
		BYTE,
		MASK
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MESSAGE_", has_type_id = false)]
	[Flags]
	public enum MessageFlags {
		ANSWERED,
		DELETED,
		DRAFT,
		FLAGGED,
		SEEN,
		ATTACHMENTS,
		ANSWERED_ALL,
		JUNK,
		SECURE,
		NOTJUNK,
		FORWARDED,
		FOLDER_FLAGGED,
		JUNK_LEARN,
		USER
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_BASIC_", type_id = "camel_mime_filter_basic_type_get_type ()")]
	public enum MimeFilterBasicType {
		INVALID,
		BASE64_ENC,
		BASE64_DEC,
		QP_ENC,
		QP_DEC,
		UU_ENC,
		UU_DEC
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_CRLF_", type_id = "camel_mime_filter_crlf_direction_get_type ()")]
	public enum MimeFilterCRLFDirection {
		ENCODE,
		DECODE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_CRLF_MODE_CRLF_", type_id = "camel_mime_filter_crlf_mode_get_type ()")]
	public enum MimeFilterCRLFMode {
		DOTS,
		ONLY
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_GZIP_MODE_", type_id = "camel_mime_filter_gzip_mode_get_type ()")]
	public enum MimeFilterGZipMode {
		ZIP,
		UNZIP
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_TOHTML_", type_id = "camel_mime_filter_to_html_flags_get_type ()")]
	[Flags]
	public enum MimeFilterToHTMLFlags {
		PRE,
		CONVERT_NL,
		CONVERT_SPACES,
		CONVERT_URLS,
		MARK_CITATION,
		CONVERT_ADDRESSES,
		ESCAPE_8BIT,
		CITE,
		PRESERVE_8BIT,
		FORMAT_FLOWED,
		QUOTE_CITATION
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MIME_FILTER_YENC_DIRECTION_", type_id = "camel_mime_filter_yenc_direction_get_type ()")]
	public enum MimeFilterYencDirection {
		ENCODE,
		DECODE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_NETWORK_SECURITY_METHOD_", type_id = "camel_network_security_method_get_type ()")]
	public enum NetworkSecurityMethod {
		NONE,
		SSL_ON_ALTERNATE_PORT,
		STARTTLS_ON_STANDARD_PORT
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_PARAM_", has_type_id = false)]
	[Flags]
	public enum ParamFlags {
		[CCode (cname = "CAMEL_PARAM_PERSISTENT")]
		PARAM_PERSISTENT
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_PROVIDER_CONF_", type_id = "camel_provider_conf_type_get_type ()")]
	public enum ProviderConfType {
		END,
		SECTION_START,
		SECTION_END,
		CHECKBOX,
		CHECKSPIN,
		ENTRY,
		LABEL,
		HIDDEN,
		OPTIONS
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_PROVIDER_", type_id = "camel_provider_flags_get_type ()")]
	[Flags]
	public enum ProviderFlags {
		IS_REMOTE,
		IS_LOCAL,
		IS_EXTERNAL,
		IS_SOURCE,
		IS_STORAGE,
		SUPPORTS_SSL,
		HAS_LICENSE,
		DISABLE_SENT_FOLDER,
		ALLOW_REAL_TRASH_FOLDER,
		ALLOW_REAL_JUNK_FOLDER,
		SUPPORTS_MOBILE_DEVICES,
		SUPPORTS_BATCH_FETCH,
		SUPPORTS_PURGE_MESSAGE_CACHE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_PROVIDER_", type_id = "camel_provider_type_get_type ()")]
	public enum ProviderType {
		STORE,
		TRANSPORT
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_URL_", has_type_id = false)]
	[Flags]
	public enum ProviderURLFlags {
		ALLOW_USER,
		ALLOW_AUTH,
		ALLOW_PASSWORD,
		ALLOW_HOST,
		ALLOW_PORT,
		ALLOW_PATH,
		NEED_USER,
		NEED_AUTH,
		NEED_PASSWORD,
		NEED_HOST,
		NEED_PORT,
		NEED_PATH,
		NEED_PATH_DIR,
		HIDDEN_USER,
		HIDDEN_AUTH,
		HIDDEN_PASSWORD,
		HIDDEN_HOST,
		HIDDEN_PORT,
		HIDDEN_PATH,
		FRAGMENT_IS_PATH,
		PATH_IS_ABSOLUTE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_MESSAGE_INFO_", has_type_id = false)]
	[Flags]
	public enum MessageInfoField {
		SUBJECT,
		FROM,
		TO,
		CC,
		MLIST,

		FLAGS,
		SIZE,

		DATE_SENT,
		DATE_RECEIVED,

		MESSAGE_ID,
		REFERENCES,
		USER_FLAGS,
		USER_TAGS,

		HEADERS,
		PREVIEW,
		CONTENT,
		LAST
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SEXP_RES_", has_type_id = false)]
	public enum SExpResultType {
		ARRAY_PTR,
		INT,
		STRING,
		BOOL,
		TIME,
		UNDEFINED
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SEXP_TERM_", has_type_id = false)]
	public enum SExpTermType {
		INT,
		BOOL,
		STRING,
		TIME,
		FUNC,
		IFUNC,
		VAR
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SASL_ANON_TRACE_", type_id = "camel_sasl_anon_trace_type_get_type ()")]
	public enum SaslAnonTraceType {
		EMAIL,
		OPAQUE,
		EMPTY
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SERVICE_", type_id = "camel_service_connection_status_get_type ()")]
	public enum ServiceConnectionStatus {
		DISCONNECTED,
		CONNECTING,
		CONNECTED,
		DISCONNECTING
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SERVICE_ERROR_", has_type_id = false)]
	public enum ServiceError {
		INVALID,
		URL_INVALID,
		UNAVAILABLE,
		CANT_AUTHENTICATE,
		NOT_CONNECTED
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SESSION_ALERT_", type_id = "camel_session_alert_type_get_type ()")]
	public enum SessionAlertType {
		INFO,
		WARNING,
		ERROR
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_SORT_", type_id = "camel_sort_type_get_type ()")]
	public enum SortType {
		ASCENDING,
		DESCENDING
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_ERROR_", has_type_id = false)]
	public enum StoreError {
		INVALID,
		NO_FOLDER
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_", type_id = "camel_store_flags_get_type ()")]
	[Flags]
	public enum StoreFlags {
		VTRASH,
		VJUNK,
		PROXY,
		IS_MIGRATING,
		REAL_JUNK_FOLDER,
		CAN_EDIT_FOLDERS,
		USE_CACHE_DIR,
		CAN_DELETE_FOLDERS_AT_ONCE,
		SUPPORTS_INITIAL_SETUP
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_FOLDER_", has_type_id = false)]
	[Flags]
	public enum StoreGetFolderFlags {
		CREATE,
		EXCL,
		BODY_INDEX,
		PRIVATE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_FOLDER_INFO_", type_id = "camel_store_get_folder_info_flags_get_type ()")]
	[Flags]
	public enum StoreGetFolderInfoFlags {
		FAST,
		RECURSIVE,
		SUBSCRIBED,
		NO_VIRTUAL,
		SUBSCRIPTION_LIST
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_INFO_FOLDER_", type_id = "camel_store_info_flags_get_type ()")]
	[Flags]
	public enum StoreInfoFlags {
		NOSELECT,
		NOINFERIORS,
		CHILDREN,
		NOCHILDREN,
		SUBSCRIBED,
		VIRTUAL,
		SYSTEM,
		VTRASH,
		SHARED_TO_ME,
		SHARED_BY_ME,
		READONLY,
		TYPE_NORMAL,
		TYPE_INBOX,
		TYPE_OUTBOX,
		TYPE_TRASH,
		TYPE_JUNK,
		TYPE_SENT,
		TYPE_CONTACTS,
		TYPE_EVENTS,
		TYPE_MEMOS,
		TYPE_TASKS,
		TYPE_FLAGGED,
		TYPE_ALL,
		TYPE_ARCHIVE,
		TYPE_DRAFTS
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STORE_", type_id = "camel_store_permission_flags_get_type ()")]
	[Flags]
	public enum StorePermissionFlags {
		READ,
		WRITE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_STREAM_BUFFER_", has_type_id = false)]
	public enum StreamBufferMode {
		BUFFER,
		NONE,
		READ,
		WRITE,
		MODE
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_TRANSFER_", type_id = "camel_transfer_encoding_get_type ()")]
	public enum TransferEncoding {
		ENCODING_DEFAULT,
		ENCODING_7BIT,
		ENCODING_8BIT,
		ENCODING_BASE64,
		ENCODING_QUOTEDPRINTABLE,
		ENCODING_BINARY,
		ENCODING_UUENCODE,
		NUM_ENCODINGS;
		public static Camel.TransferEncoding from_string (string string);
		public static unowned string to_string (Camel.TransferEncoding encoding);
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_URL_HIDE_", has_type_id = false)]
	[Flags]
	public enum URLFlags {
		PARAMS,
		AUTH
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_cipher_validity_encrypt_t", cprefix = "CAMEL_CIPHER_VALIDITY_ENCRYPT_", has_type_id = false)]
	public enum _cipher_validity_encrypt_t {
		NONE,
		WEAK,
		ENCRYPTED,
		STRONG
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_cipher_validity_mode_t", cprefix = "CAMEL_CIPHER_VALIDITY_", has_type_id = false)]
	public enum _cipher_validity_mode_t {
		SIGN,
		ENCRYPT
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_cipher_validity_sign_t", cprefix = "CAMEL_CIPHER_VALIDITY_SIGN_", has_type_id = false)]
	public enum _cipher_validity_sign_t {
		NONE,
		GOOD,
		BAD,
		UNKNOWN,
		NEED_PUBLIC_KEY
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_header_address_t", cprefix = "CAMEL_HEADER_ADDRESS_", has_type_id = false)]
	public enum _header_address_t {
		NONE,
		NAME,
		GROUP
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_html_parser_t", cprefix = "CAMEL_HTML_PARSER_", has_type_id = false)]
	public enum _html_parser_t {
		DATA,
		ENT,
		ELEMENT,
		TAG,
		DTDENT,
		COMMENT0,
		COMMENT,
		ATTR0,
		ATTR,
		VAL0,
		VAL,
		VAL_ENT,
		EOD,
		EOF
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_mime_parser_state_t", cprefix = "CAMEL_MIME_PARSER_STATE_", has_type_id = false)]
	public enum _mime_parser_state_t {
		INITIAL,
		PRE_FROM,
		FROM,
		HEADER,
		BODY,
		MULTIPART,
		MESSAGE,
		PART,
		END,
		EOF,
		PRE_FROM_END,
		FROM_END,
		HEADER_END,
		BODY_END,
		MULTIPART_END,
		MESSAGE_END
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_smime_describe_t", cprefix = "CAMEL_SMIME_", has_type_id = false)]
	[Flags]
	public enum _smime_describe_t {
		SIGNED,
		ENCRYPTED,
		CERTS,
		CRLS
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_smime_sign_t", cprefix = "CAMEL_SMIME_SIGN_", has_type_id = false)]
	public enum _smime_sign_t {
		CLEARSIGN,
		ENVELOPED
	}
	[CCode (cheader_filename = "camel/camel.h", cname = "camel_vtrash_folder_t", cprefix = "CAMEL_VTRASH_FOLDER_", has_type_id = false)]
	public enum _vtrash_folder_t {
		TRASH,
		JUNK,
		LAST
	}
	[CCode (cheader_filename = "camel/camel.h", cprefix = "CAMEL_ERROR_")]
	public errordomain Error {
		[CCode (cname = "CAMEL_ERROR_GENERIC")]
		ERROR_GENERIC;
		public static GLib.Quark quark ();
	}
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate int DBCollate (void* enc, int length1, void* data1, int length2, void* data2);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate int DBSelectCB (void* data, int ncol, string colvalues, string colnames);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate unowned Camel.Folder FilterGetFolderFunc (Camel.FilterDriver driver, string uri, void* data) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 2.9)]
	public delegate void FilterPlaySoundFunc (Camel.FilterDriver driver, string filename);
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 3.9)]
	public delegate void FilterShellFunc (Camel.FilterDriver driver, int argc, string argv);
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 4.9)]
	public delegate void FilterStatusFunc (Camel.FilterDriver driver, void* status, int pc, string desc);
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 1.9)]
	public delegate void FilterSystemBeepFunc (Camel.FilterDriver driver);
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 2.9)]
	public delegate void ForeachInfoData (Camel.VeeMessageInfoData mi_data, Camel.Folder subfolder);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate string IndexNorm (Camel.Index index, string word, void* data);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate int ProviderAutoDetectFunc (Camel.URL url, GLib.HashTable<void*,void*> auto_detected) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate unowned Camel.SExpResult? SExpFunc (Camel.SExp sexp, int argc, Camel.SExpResult argv, void* data);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate unowned Camel.SExpResult? SExpIFunc (Camel.SExp sexp, int argc, Camel.SExpTerm argv, void* data);
	[CCode (cheader_filename = "camel/camel.h", instance_pos = 2.9)]
	public delegate void SessionCallback (Camel.Session session, GLib.Cancellable? cancellable) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate void TextIndexFunc (Camel.TextIndex idx, string word, string buffer);
	[CCode (cheader_filename = "camel/camel.h", has_target = false)]
	public delegate bool UrlScanFunc (string @in, string pos, string inend, Camel.UrlMatch match);
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_BLOCK_SIZE")]
	public const int BLOCK_SIZE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_BLOCK_SIZE_BITS")]
	public const int BLOCK_SIZE_BITS;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_FILE")]
	public const string DB_FILE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_FREE_CACHE_SIZE")]
	public const int DB_FREE_CACHE_SIZE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_IN_MEMORY_DB")]
	public const string DB_IN_MEMORY_DB;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_IN_MEMORY_TABLE")]
	public const string DB_IN_MEMORY_TABLE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_IN_MEMORY_TABLE_LIMIT")]
	public const int DB_IN_MEMORY_TABLE_LIMIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DB_SLEEP_INTERVAL")]
	public const int DB_SLEEP_INTERVAL;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DEBUG_IMAP")]
	public const string DEBUG_IMAP;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DEBUG_IMAP_FOLDER")]
	public const string DEBUG_IMAP_FOLDER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_DOT_LOCK_REFRESH")]
	public const int DOT_LOCK_REFRESH;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_FOLDER_TYPE_BIT")]
	public const int FOLDER_TYPE_BIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_FOLDER_TYPE_MASK")]
	public const int FOLDER_TYPE_MASK;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_INFO_FOLDER_TYPE_MASK")]
	public const int STORE_INFO_FOLDER_TYPE_MASK;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_FOLD_MAX_SIZE")]
	public const int FOLD_MAX_SIZE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_FOLD_SIZE")]
	public const int FOLD_SIZE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_INDEX_DELETED")]
	public const int INDEX_DELETED;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_KEY_TABLE_MAX_KEY")]
	public const int KEY_TABLE_MAX_KEY;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_LOCK_DELAY")]
	public const int LOCK_DELAY;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_LOCK_DOT_DELAY")]
	public const int LOCK_DOT_DELAY;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_LOCK_DOT_RETRY")]
	public const int LOCK_DOT_RETRY;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_LOCK_DOT_STALE")]
	public const int LOCK_DOT_STALE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_LOCK_RETRY")]
	public const int LOCK_RETRY;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MESSAGE_DATE_CURRENT")]
	public const int MESSAGE_DATE_CURRENT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MESSAGE_SYSTEM_MASK")]
	public const int MESSAGE_SYSTEM_MASK;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_FILTER_ENRICHED_IS_RICHTEXT")]
	public const int MIME_FILTER_ENRICHED_IS_RICHTEXT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_BEGIN")]
	public const int MIME_YDECODE_STATE_BEGIN;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_DECODE")]
	public const int MIME_YDECODE_STATE_DECODE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_END")]
	public const int MIME_YDECODE_STATE_END;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_EOLN")]
	public const int MIME_YDECODE_STATE_EOLN;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_ESCAPE")]
	public const int MIME_YDECODE_STATE_ESCAPE;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_INIT")]
	public const int MIME_YDECODE_STATE_INIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YDECODE_STATE_PART")]
	public const int MIME_YDECODE_STATE_PART;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YENCODE_CRC_INIT")]
	public const int MIME_YENCODE_CRC_INIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_MIME_YENCODE_STATE_INIT")]
	public const int MIME_YENCODE_STATE_INIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_BCC")]
	public const string RECIPIENT_TYPE_BCC;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_CC")]
	public const string RECIPIENT_TYPE_CC;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_RESENT_BCC")]
	public const string RECIPIENT_TYPE_RESENT_BCC;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_RESENT_CC")]
	public const string RECIPIENT_TYPE_RESENT_CC;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_RESENT_TO")]
	public const string RECIPIENT_TYPE_RESENT_TO;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_RECIPIENT_TYPE_TO")]
	public const string RECIPIENT_TYPE_TO;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_INFO_FOLDER_UNKNOWN")]
	public const int STORE_INFO_FOLDER_UNKNOWN;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_SETUP_ARCHIVE_FOLDER")]
	public const string STORE_SETUP_ARCHIVE_FOLDER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_SETUP_DRAFTS_FOLDER")]
	public const string STORE_SETUP_DRAFTS_FOLDER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_SETUP_SENT_FOLDER")]
	public const string STORE_SETUP_SENT_FOLDER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_STORE_SETUP_TEMPLATES_FOLDER")]
	public const string STORE_SETUP_TEMPLATES_FOLDER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_UNMATCHED_NAME")]
	public const string UNMATCHED_NAME;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_HIDE_ALL")]
	public const int URL_HIDE_ALL;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_AUTH")]
	public const int URL_PART_AUTH;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_HIDDEN")]
	public const int URL_PART_HIDDEN;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_HOST")]
	public const int URL_PART_HOST;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_NEED")]
	public const int URL_PART_NEED;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_PASSWORD")]
	public const int URL_PART_PASSWORD;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_PATH")]
	public const int URL_PART_PATH;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_PATH_DIR")]
	public const int URL_PART_PATH_DIR;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_PORT")]
	public const int URL_PART_PORT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_URL_PART_USER")]
	public const int URL_PART_USER;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_UUDECODE_STATE_BEGIN")]
	public const int UUDECODE_STATE_BEGIN;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_UUDECODE_STATE_END")]
	public const int UUDECODE_STATE_END;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_UUDECODE_STATE_INIT")]
	public const int UUDECODE_STATE_INIT;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_UUDECODE_STATE_MASK")]
	public const int UUDECODE_STATE_MASK;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_VJUNK_NAME")]
	public const string VJUNK_NAME;
	[CCode (cheader_filename = "camel/camel.h", cname = "CAMEL_VTRASH_NAME")]
	public const string VTRASH_NAME;
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned GLib.Binding binding_bind_property (void* source, string source_property, void* target, string target_property, GLib.BindingFlags flags);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned GLib.Binding binding_bind_property_full (GLib.Object source, string source_property, GLib.Object target, string target_property, GLib.BindingFlags flags, GLib.BindingTransformFunc? transform_to, owned GLib.BindingTransformFunc? transform_from);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned GLib.Binding binding_bind_property_with_closures (GLib.Object source, string source_property, GLib.Object target, string target_property, GLib.BindingFlags flags, GLib.Closure transform_to, GLib.Closure transform_from);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int cipher_canonical_to_stream (Camel.MimePart part, uint32 flags, Camel.Stream ostream, GLib.Cancellable? cancellable = null) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static void content_info_dump (Camel.MessageContentInfo ci, int depth);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string content_transfer_encoding_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static bool debug (string mode);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void debug_end ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static GLib.StringBuilder debug_get_backtrace ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static void debug_init ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static void debug_ref_unref_dump_backtraces ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static void debug_ref_unref_push_backtrace (GLib.StringBuilder backtrace, uint object_ref_count);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void debug_ref_unref_push_backtrace_for_object (void* _object);
	[CCode (cheader_filename = "camel/camel.h")]
	public static bool debug_start (string mode);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string enriched_to_html (string @in, uint32 flags);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_fixed_int32 (void* @in, int32 dest);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_fixed_string (void* @in, string str, size_t len);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_gsize (void* @in, size_t dest);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_off_t (void* @in, size_t dest);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_string (void* @in, string str);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_time_t (void* @in, long dest);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_decode_uint32 (void* @in, uint32 dest);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_fixed_int32 (void* @out, int32 value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_fixed_string (void* @out, string str, size_t len);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_gsize (void* @out, size_t value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_off_t (void* @out, size_t value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_string (void* @out, string str);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_time_t (void* @out, long value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int file_util_encode_uint32 (void* @out, uint32 value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string file_util_safe_filename (string name);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string file_util_savename (string filename);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void freeaddrinfo (void* host);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void* getaddrinfo (string name, string service, void* hints, GLib.Cancellable? cancellable = null) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_contentid_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static long header_decode_date (string str, int tz_offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int header_decode_int (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_decode_string (string @in, string default_charset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_encode_phrase (uint8 @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_encode_string (uint8 @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_fold (string @in, size_t headerlen);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_format_ctext (string @in, string default_charset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_format_date (long date, int tz_offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_location_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static Camel.HeaderAddress header_mailbox_decode (string @in, string charset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_mime_decode (string @in, int maj, int min);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_msgid_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_msgid_generate (string domain);
	[CCode (cheader_filename = "camel/camel.h")]
	public static GLib.SList<string> header_newsgroups_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_param (void* @params, string name);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_append (void* list, string name, string value, int offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_append_parse (void* list, string header, int offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_raw_check_mailing_list (void* list);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_clear (void* list);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string header_raw_find (void* list, string name, int offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string header_raw_find_next (void* list, string name, int offset, string last);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_fold (void* list);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_remove (void* list, string name);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void header_raw_replace (void* list, string name, string value, int offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static GLib.SList<string> header_references_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void* header_set_param (void* paramsp, string name, string value);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_token_decode (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string header_unfold (string @in);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string host_idna_to_ascii (string host);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t iconv (GLib.IConv cd, string inbuf, size_t inleft, string outbuf, size_t outleft);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string iconv_charset_language (string charset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string iconv_charset_name (string charset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void iconv_close (GLib.IConv cd);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string iconv_locale_charset ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string iconv_locale_language ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static int init (string certdb_dir, bool nss_init);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void localtime_with_offset (long tt, [CCode (type = "tm*")] Posix.tm tm, int offset);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_dot (string path) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_fcntl (int fd, Camel.LockType type) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_flock (int fd, Camel.LockType type) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_folder (string path, int fd, Camel.LockType type) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_helper_lock (string path) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static int lock_helper_unlock (int lockid);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void* memchunk_alloc (Camel.MemChunk memchunk);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void* memchunk_alloc0 (Camel.MemChunk memchunk);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void memchunk_clean (Camel.MemChunk memchunk);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void memchunk_destroy (Camel.MemChunk memchunk);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void memchunk_empty (Camel.MemChunk memchunk);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void memchunk_free (Camel.MemChunk memchunk, void* mem);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void mempool_destroy (Camel.MemPool pool);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void mempool_flush (Camel.MemPool pool, int freeall);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string mempool_strdup (Camel.MemPool pool, string str);
	[CCode (cheader_filename = "camel/camel.h")]
	public static long mktime_utc ([CCode (type = "tm*")] Posix.tm tm);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int movemail (string source, string dest) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static void msgport_destroy (Camel.MsgPort msgport);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int msgport_fd (Camel.MsgPort msgport);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void msgport_push (Camel.MsgPort msgport, Camel.Msg msg);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void msgport_reply (Camel.Msg msg);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void pointer_tracker_dump ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static void pointer_tracker_track_with_info (void* ptr, string info);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void pointer_tracker_untrack (void* ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string pstring_add (string string, bool own);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void pstring_dump_stat ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static void pstring_free (string string);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string pstring_peek (string string);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string pstring_strdup (string string);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t quoted_decode_step (uint8 @in, size_t len, uint8 @out, int savestate, int saveme);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t quoted_encode_close (uint8 @in, size_t len, uint8 @out, int state, int save);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t quoted_encode_step (uint8 @in, size_t len, uint8 @out, int state, int save);
	[CCode (cheader_filename = "camel/camel.h")]
	public static ssize_t read (int fd, string buf, size_t n, GLib.Cancellable? cancellable = null) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static void shutdown ();
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string store_info_path (Camel.StoreSummary summary, Camel.StoreInfo info);
	[CCode (cheader_filename = "camel/camel.h")]
	public static int strcase_equal (void* a, void* b);
	[CCode (cheader_filename = "camel/camel.h")]
	public static uint strcase_hash (void* v);
	[CCode (cheader_filename = "camel/camel.h")]
	public static unowned string strdown (string str);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string strstrcase (string haystack, string needle);
	[CCode (cheader_filename = "camel/camel.h")]
	public static Camel.MessageFlags system_flag (string name);
	[CCode (cheader_filename = "camel/camel.h")]
	public static bool system_flag_get (Camel.MessageFlags flags, string name);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string text_to_html (string @in, Camel.MimeFilterToHTMLFlags flags, uint32 color);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string ucs2_utf8 (string ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void unlock_dot (string path);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void unlock_fcntl (int fd);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void unlock_flock (int fd);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void unlock_folder (string path, int fd);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string utf7_utf8 (string ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static uint32 utf8_getc (uint8 ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static uint32 utf8_getc_limit (uint8 ptr, uint8 end);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string utf8_make_valid (string text);
	[CCode (cheader_filename = "camel/camel.h")]
	public static void utf8_putc (uint8 ptr, uint32 c);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string utf8_ucs2 (string ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static string utf8_utf7 (string ptr);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t uudecode_step (uint8 @in, size_t inlen, uint8 @out, int state, uint32 save);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t uuencode_close (uint8 @in, size_t len, uint8 @out, uint8 uubuf, int state, uint32 save);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t uuencode_step (uint8 @in, size_t len, uint8 @out, uint8 uubuf, int state, uint32 save);
	[CCode (cheader_filename = "camel/camel.h")]
	public static ssize_t write (int fd, string buf, size_t n, GLib.Cancellable? cancellable = null) throws GLib.Error;
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t ydecode_step (uint8 @in, size_t inlen, uint8 @out, int state, uint32 pcrc, uint32 crc);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t yencode_close (uint8 @in, size_t inlen, uint8 @out, int state, uint32 pcrc, uint32 crc);
	[CCode (cheader_filename = "camel/camel.h")]
	public static size_t yencode_step (uint8 @in, size_t inlen, uint8 @out, int state, uint32 pcrc, uint32 crc);
}
